# 8.1 디스크 읽기 방식
- DB 성능 튜닝은 디스크 IO를 줄이는 것이 관건이다.

## 8.1.1 HDD와 SSD
- SSD는 기존 HDD에서 원판을 제거하고 플래시 메모리를 장착하고 있는데, 디스크 원판을 회전시킬 필요가 없어 빨리 데이터를 읽고 쓸 수 있다.
  - DRAM과 HDD는 차이가 심함 (10만배)
  - DRAM과 SSD 차이는 심하지 않음 (1000배)`
- 디비 서버는 대부분 랜덤 IO 작업이 대부분인데, SSD는 HDD에 비해 순차 IO는 조금 빠르거나 비슷하지만, 랜덤 IO 작업에서 월등히 차이가 난다.

## 랜덤 IO와 순차 IO
- 랜덤 IO는 HDD의 원판을 돌려서 읽어야 할 데이터가 저장된 위치로 헤더를 이동시킨다음 데이터를 읽는 것을 의미한다.
- 순차 IO는 3개의 페이지를 기록하기 위해 1번의 시스템 콜을 요청했다.
- 랜덤 IO는 3개의 페이지를 디스크에 기록하기 위해 3번의 시스템 콜을 요청했다.
- 디스크를 쓰고 읽는데 걸리는 시간은 데스크 헤더를 움직여서 읽고 쓸 위치로 옮기는 단계서 결정된다. 즉, 헤더를 덜 움직이는게 빠른다.
- 우리가 말하는 쿼리를 튜닝하는 것은 랜덤IO를 순차IO로 바꾸는게 아니라 랜덤IO 자체를 줄이는 것이 목적이다.
- 다시 말하면 쿼리를 처리하는데 꼭 필요한 데이터만 읽도록 쿼리를 개선하는 것이다.

# 8.2 인덱스란?
- DB의 인덱스는 책의 “색인”과 같다. 책의 내용은 데이터 파일에 해당된다.
- 책의 찾아보기에 있는 페이지 번호는 데이터 파일에 저장된 레코드의 주소에 비유 된다.
- 인덱스는 칼럼의 값과 해당 레코드가 저장된 주소를 key-value 형식으로 만들어 둔다.
- 또한, 인덱스는 칼럼의 값을 주어진 순서로 정렬해서 보관한다.

- DBMS에서 인덱스는 INSERT,UPDATE,DELETE 성능을 희생하고 데이터의 읽기 속도를 높이는 기능이다.
- 즉, 테이블의 인덱스를 하나 더 추가할지 말지는 데이터의 저장 속도를 어디까지 희생할 수 있는지, 읽기 속도를 얼마나 더 빠르게 만들어야 하느냐에 따라 결정해야 한다.
- 인덱스는 역할별로 구분시 두가지로 볼 수 있다.
1. 프라이머리 키
- 레코드를 대표하는 칼럼의 값으로 만들어진 인덱스
- 식별자라고도 부른다.
- NULL 값을 허용하지 않으며 중복을 허용하지 않는다.
2. 세컨더리 인덱스
- 프라이머리 키를 제외한 나머지 모든 인덱스는 세컨더리 인덱스다.

- 저장방식별로 구분하면 많이 있지만 대표적으로 B-Tree인덱스와 Hash 인덱스가 있다.
1. B-Tree
- 일반적으로 사용되는 인덱스 알고리즘이며, 오래전에 도입되었다. 그만큼 성숙도가 높다.
- B-Tree 인덱스는 칼럼의 값을 변형하지 않고 원래의 값을 이용한다.
2. Hash 인덱스
- 칼럼의 값으로 해시값을 계산하며, 매우 빠른 검색을 지원한다.
- 하지만 값을 변형해서 인덱싱하므로 전방(prefix) 일치와 같이 값의 일부만 검색하거나 범위를 검색할 때는 사용할 수 없다.
- 주로 메모리 기반의 DB에서 많이 사용 한다.

- 중복여부는
1. 유니크 인덱스
2. non 유니크 인덱스

- 기능별로는
1. 전문 검색용 인덱스
2. 공간 검색용 인덱스

# 8.3 B-Tree 인덱스
- 가장 일반적으로 사용되고 가장 먼저 도입된 알고리즘이다.
- 변형된 형태인 B+Tree와 B*Tree가 있다.
- B-Tree의 BN는 Binary가 아니라 Balanced 다.
- 인덱스 구조체 내에서 항상 정렬된 상태로 유지한다.

## 8.3.1 구조 및 특성
- 트리구조이다.
- 최상위 루트 노드 1개가 존재하고 하위에 자식 노드들이 붙어 있다.
- 가장 하위에 있는 노드를 리프노드라 한다.
- 루트노드도 아니고 리프노드도 아닌 중간의 노드를 브랜치 노드라 한다.
- 인덱스의 리프 노드는 항상 실제 데이터 레코드의 주솟값을 가지고 있다.
- 인덱스의 키값은 정렬되어 있지만 데이터 파일의 레코드는 정렬돼 있지 않다.

```
InnoDB 테이블의 레코드는 클러스터 되어 디스크에 저장되므로 기본적으로 프라이머리 키 순서로 정렬되어 저장된다. 
클러스터링이란 비슷한 값을 최대한 모아서 저장하는 방식인데 뒤에서 자세히 살펴보자.
```

- MyISAM 테이블의 인덱스와 데이터 파일의 관계다.
- 세컨더리 인덱스가 **물리적인 주소인 데이터 레코드의 주소**를 가지고 있다.

- InnoDB 테이블의 인덱스와 데이터 파일의 관계다.
- 세컨더리 인덱스가 데이터 레코드 주소가 아닌 **논리적인 주소인 프라이머리 키**를 가지고 있다.
- 즉, 인덱스를 태우더라도 바로 데이터에 접근하지 못하고 프라이머리 키 인덱스를 통해 다시 검색해야 한다.
- 위와 같이 보면 성능이 떨어질 것처럼 보이지만 각각 장단점이 있다. (8.8절 클러스터링 인덱스’에서 자세히)

## 8.3.2 B-Tree 인덱스 키 추가 및 삭제

### 8.3.2.1 인덱스 키 추가
- 새로운 키 값이 B-Tree에 저장될 때 테이블의 엔진에 따라 새로운 키 값이 즉시 인덱스에 저장될 수도 있고 그렇지 않을 수도 있다.
- B-Tree에 저장될 때는 저장될 키 값을 이용해 B-Tree 상의 적절한 위치를 검색해야 한다.
- 저장될 위치가 결정되면 레코드의 키 값과 대상 레코드의 주소 정보를 B-Tree의 리프노드에 저장한다.
- 리프 노드가 꽉 차서 더는 저장할 수 없을 때는 리프 노드가 분리돼야 하는데, 이는 상위 브랜치 노드 까지 처리의 범위가 넓어진다.
- 이러한 작업 탓에 B-Tree는 상대적으로 쓰기 작업(새로운 키를 추가하는 작업)에 비용이 많이 든다.

- 레코드 추가 비용 = 1 / 인덱스 비용 = 1.5
- 이 비용의 대부분이 메모리와 PCU 처리 시간이 아닌 디스크 IO 시간이다.

- MyISAM이나 MEMORY 엔진의 테이블은 INSERT 문장이 실행되면 즉시 새로운 키 값을 B-Tree 인덱스에 변경한다.
- 하지만 InnoDB 는 필요하면 인덱스 키 추가 작업을 지연시켜 나중에 처리할 수 있다.
- 하지만 PK나 유니크 인덱스의 경우 중복 체크가 필요하기 때문에 B-Tree에 추가하거나 삭제한다.

```
💡 체인지 버퍼란?
인덱스 업데이트 작업시 인덱스가 버퍼 풀에 없을때 실행하지 않고 임시 공간에 저장해 두고 바로 사용자에게 결과를 반환하는 형태를 띄게된다. 이때 사용하는 임시 메모리 공간을 체인지 버퍼라고 한다.
- 변경 사항을 보관
버퍼링된 변경 사항은 추후 읽기 작업에 의해 페이지가 버퍼 풀에 로드될 때 병합된다.
(4.2.10절 체인지 버퍼 참고)
```

### 8.3.2.2 인덱스 키 삭제

- 삭제는 그냥 삭제 된다.
- MySQL 5.5 이상의 InnoDB 에선 삭제 또한 지연 처리할 수 있다.

### 8.3.2.3 인덱스 키 변경

- 기존 인덱스 키 값을 삭제한 후 새로운 인덱스 키 값을 추가하는 작업으로 처리된다.

### 8.3.2.4 인덱스 키 검색
- 인덱스를 검색하는 작업은 B-Tree의 루트 노드부터 시작해 브랜치 노드를 거쳐 최종 리프노드까지 이동하면서 비교 작업을 수행하는데, 이 과정을 트리 탐색이라고 한다.
- 인덱스 트리 탐색은 select에서만 사용하는 것이 아니라 update나 delete를 처리하기 위해 항상 해당 레코드를 먼저 검색해야 할 경우에도 사용된다.
- B-Tree 인덱스를 이용한 검색은 100% 일치 또는 값의 앞부분만 일치하는 경우에 사용할 수 있다.
- 부등호 조건도 인덱스를 활용할 수 있지만, 키 값의 뒷부분만 검색하는 용도는 인덱스를 사용할 수 없다.
- 인덱스 키값에 함수 등을 써서 변형을 가하면 인덱스를 탈 수 없다.
- 변형된 값은 인덱스에 존재하지 않기 때문이다.

## 8.3.3 B-Tree 인덱스 사용에 영향을 미치는 요소

### 8.3.3.1 인덱스 키 값의 크기
- InnoDB 스토리지 엔진에서 디스크에 데이터를 저장하는 가장 기본 단위를 페이지 또는 블록이라 한다.
- MySQL 5.7부터 InnoDB 페이지 크기를 innodb_page_size를 이용해 4KB ~ 64KB로 선택할 수 있지만, 기본값은 16KB다.

- 인덱스 키는 16바이트, 자식노드 주소는 12바이트라 가정하자.
- 위 인덱스 페이지(16KB)에선 몇개의 키를 저장할 수 있을까?
- 16 * 1024 / (16 + 12) = 585개 저장할 수 있다. (바이트로 변환하여 계산)
- 키가 32 바이트면?
- 16 * 1024 / (32 + 12) = 372개 저장할 수 있다. (바이트로 변환하여 계산)
- select 쿼리가 500개를 읽어야 한다면 전자는 페이지를 1개, 후자는 페이지를 2개 읽어야 한다.
- 결국 인덱스를 구성하는 키 값의 크기가 커지면 디스크로부터 읽어야 하는 횟수가 늘어나고, 그만큼 느려진다.
- 페이지를 하나더 읽는거 자체가 IO라 보는듯

### 8.3.3.2 B-Tree 깊이
- B-Tree 깊이가 3인 경우 가정
    - 키값이 16바이트인 경우 최대 2억개 보관
    - 키값이 32바이트 인경우 5천만개 보관
- 인덱스 키 값의 크기가 커지면 커질수록 하나의 인덱스 페이지가 담을 수 있는 인덱스 키 값의 개수가 적어지고, 그때문에 같은 레코드 건수라 하더라도 B-Tree의 깊이가 깊어져서 디스크 읽기가 더 많이 필요하게 된다.
- 5단계 이상 깊어지는 건 흔치 않다.

### 8.3.3.3 선택도(기수성)

- 유니크한 값의 수를 의미한다.
- 중복된 값이 많아지면(유니크 값 줄어들면) 기수성은 낮아지고 동시에 선택도 또한 떨어진다.
- 인덱스는 선택도가 높을수록(유니크가 많아질수록) 검색 대상이 줄어들기 때문에 그만큼 빠르게 처리된다.

```
선택도가 좋지 않다고 하더라도 정렬이나 그룹핑 같은 작업을 위해 인덱스를 만드는 것이 훨씬 나은 경우도 많다.
```

- 전체 레코드 데이터 건수는 1만 건
- 케이스 A - country 칼럼의 유니크한 값의 개수가 10개
- 케이스 B - country 칼럼의 유니크한 값의 개수가 1000개

```sql
SELECT *
FROM  tb_test
WHERE country = 'KOREA' AND city = 'SEOUL';
```
- A 케이스는 평균 1000건 (10000 / 10), B 케이스는 평균 10 ( 10000/ 1000) 건이 조회될 수 있다.
- A, B 케이스 모두 실제 모든 조건을 만족하는 레코드가 단 1건만 있었다고 하면 A 케이스의 경우 999건의 레코드를 더 읽었고 B 케이스의 경우 9 건만 더 읽었기 때문에 A 케이스의 경우 (중복도가 많은 경우) 비효율 적이다.

### 8.3.3.4 읽어야 하는 레코드의 건수

- 인덱스를 통해 테이블의 레코드를 읽는 것은 인덱스를 거치지 않고 바로 테이블의 레코드를 읽는 것 보다 높은 비용이 드는 작업이다.
- 인덱스를 통해 읽어야 할 레코드의 건수가 전체 테이블 레코드의 20% ~ 25%를 넘어서면 인덱스를 이용하지 않고 테이블을 모두 직접 읽어서 필요한 레코드만 필터링 방식으로 처리하는 것이 효율적이다.

## 8.3.4 B-Tree 인덱스를 통한 데이터 읽기

### 8.3.4.1 인덱스 레인지 스캔

```sql
select * from employees where first_name between 'ebbe' and 'Gad';
```

- 인덱스 레인지 스캔은 검색해야 할 인덱스의 범위가 결정됐을 때 사용하는 방식이다.
- 루트노드에서 부터 비교를 시작해 브랜치 노드를 거쳐 최종적으로 리프 노드까지 찾아 들어간다.
- 시작 위치를 찾으면 그때부터 리프 노드의 레코드만 순서대로 읽으면 된다.
- 실제 데이터 파일의 레코드를 읽는 과정도 살펴보자

- 레코드 한건 한건 랜덤 IO가 일어난다.
- 그래서 인덱스를 통해 데이터 레코드를 읽는 작업이 비용이 많이 드는것으로 분류된다.
- 앞서 말한거와 같이 인덱스를 통해 데이터를 읽을때 레코드 수가 20% ~ 25%가 넘으면 인덱스를 통한 읽기보다 테이블의 데이터를 직접 읽는 것이 더 효율적으로 처리된다.

- 인덱스 레인지 스캔의 3단계
1. 인덱스에서 조건을 만족하는 값이 저장된 위치를 탐색
2. 1번에서 탐색된 위치부터 필요한 만큼 인덱스를 차례대로 쭉 읽는다. (스캔)
3. 2번에서 읽어들인 인덱스 키와 레코드 주소를 이용해 레코드가 저장된 페이지를 가져오고 최종 레코드를 읽는다.
- 커버링 인덱스의 경우 3번 과정은 스킵 되므로, 성능이 빠르다.

### 8.3.4.2 인덱스 풀 스캔

- 인덱스의 처음부터 끝까지 모두 읽는 방식
- 쿼리의 조건절에 사용된 칼럼이 인덱스의 첫번째 칼럼이 아닌 경우 사용 된다.
    - 인덱스는 (A,B,C)로 구성되어 있지만, 쿼리의 조건절은 B 칼럼이나 C 칼럼으로 검색하는 경우다.
- 일반적으로 인덱스의 크기는 테이블의 크기보다 작으므로 직접 테이블을 처음부터 끝까지 읽는것 보다는 인덱스만 읽는 것이 효율적이다. 따라서, 인덱스 레인지 스캔보다는 빠르지 않지만 테이블 풀 스캔보다는 효율적이다.
- 테이블 풀 스캔보다 효율적인 경우는 커버링 인덱스일 경우만 이지 않을까 싶다.
- 앞서 마찬가지로 조회하는 레코드의 20~25% 이상이면 풀스캔이 효율적일 것 같다.

- 한가지 예시

```sql
-- 인덱스는 (gender, birth_date)
SELECT gender, birth_date
FROM employees 
WHERE birth_date >= '1965-02-01';
```

- 인덱스 스킵 스캔이 적용되지 않는다는 가정하에 where 절에 gender가 없기 때문에 birth_date를 인덱스 풀스캔으로 읽는다.
- 인덱스에 있는 gender와 birth_date만 있으면 처리를 완료할 수 있기 때문에 인덱스 풀스캔으로 읽은 것이다.
- 만약 select절이 아스테리카였으면 테이블 풀 스캔을 실행했을 것이다.
    - 왜냐면 인덱스 풀스캔만으로 처리할 수 없으니 남은 선택지는 테이블 풀 스캔 밖에 없으니까..?

### 8.3.4.3 루스 인덱스 스캔

- 듬성듬성 인덱스를 읽는 방식이다.
- 중간에 필요치 않은 인덱스 키 값은 무시하고 다음으로 넘어가는 형태로 처리한다.
- 일반적으로 GROUP BY 또는 집함 함수 가운데 max() 또는 min() 함수에 대해 최적화를 하는 경우에 사용된다.

```sql
SELECT dept_no, MIN(emp_no) 
FROM dept_emp 
WHERE dep_no BETWEEN 'd002' AND 'd004' 
GROUP BY dept_no;
```

- 인덱스가 `(dept_no, emp_no)` 이라고 가정
- MIN(EMP_NO)를 구하기 위해선 제일 첫번째 인덱스 칼럼만 읽으면 된다
    - 순서대로 정렬되어 있으니까..
- 따라서 옵티마이저는 듬성듬성 읽어도 된다고 판단.

### 8.3.4.4 인덱스 스킵 스갠

- MySQL 8.0부터 옵티마이저가 **앞 칼럼을 뛰어넘어서 뒤 칼럼만으로도 인덱스 검색이 가능**하게 해주는 최적화 기능이다.
- DB에서 인덱스의 핵심은 값이 정렬돼 있다는 것이고 이로 인해 인덱스를 구성하는 칼럼의 순서가 매우 중요하다.
- 다음과 같은 인덱스가 있다.

```sql
ALTER table employees ADD INDEX ix_gender_birthdate (gender, birth_date);
```

- 위 인덱스를 사용하려면 WHERE 조건절에 GENDER 칼럼에 대한 비교 조건이 있어야 한다.

```sql
-- 인덱스 사용X
SELECT * FROM employees WHERE birth_date >= '1965-02-01';

-- 인덱스 사용O
SELECT * FROM employees WHERE gender='M' AND birth_date >= '1965-02-01';
```

- 첫 번째 쿼리의 경우 인덱스를 사용할 수 없어서 인덱스를 새로 생성했어야 했다. 하지만 MYSQL8.0 부터는 인덱스 스킵 스캔으로 처리가 가능하게 되었다.
- 실행계획

- type: range
- extra: using index for skip scan
- 옵티마이저는 gender 칼럼에서 유니크한 값을 모두 조회해서 주어진 쿼리에 gender 칼럼의 조건을 추가해서 쿼리를 다시 실행하는 형태로 처리한다.

- 하지만 새로 도입된 기능이라 다음과 같은 단점이 있다.
    - **where 조건절에 조건이 없는 인덱스의 선행 칼럼의 유니크한 값의 개수가 적어야 함**
        - 적다는 것은 상대적인 개념이라 구체적인 숫자로 정의 하기는 힘듬
        - 적어야 해당 칼럼을 스킵할때 더 많은 행을 스킵할 수 있기 때문이다.
        - 적을 수록 인덱스 스킵 스캔의 효율성이 증가한다고 생각 해야 함
- **쿼리가 인덱스에 존재하는 칼럼만으로 처리 가능 해야 함(커버링 인덱스)**
    - 인덱스에 포함된 칼럼 이외에도 나머지 칼럼을 필요로 하기 때문에 인덱스 스킵 스캔을 사용하지 못하고 풀 테이블 스캔으로 수행 한다.

## 8.3.5 다중 칼럼 인덱스

- 실제 서비스에선 다중 칼럼 인덱스를 더 많이 사용 한다.
- 인덱스의 두번째 칼럼은 첫번째 칼럼에 의존해서 정렬되어 있다.
- 다중 칼럼 인덱스는 인덱스 내에서 각 칼럼의 위치가 상당히 중요하다.
    - 앞쪽에 카디널리티가 높은 게 있으면 데이터 필터링이 더 많이 된다.

## 8.3.6 B-Tree 인덱스의 정렬 및 스캔 방향

- 인덱스는 기본은 오름차순이지만 내림차순으로도 적용할 수 있다.

### 8.3.6.1 인덱스의 정렬

- MySQL 8.0부터 정렬 순서를 혼합한 인덱스도 생성 가능해졌다.

```sql
create index ix_teamname_userscore on employees (team_name asc, user_score desc);
```

**인덱스 스캔 방향**

```sql
// 인덱스는 first_name asc로 만들어져 있음
select *
from employees
order by firse_name desc
limit 1;
```

- 인덱스를 처음부터 오름차순으로 읽어 마지막 값 하나를 가져올까?
- 아니다. 최댓값부터 거꾸로 읽으면 하나만 탐색해서 가져올 수 있다는 것은 옵티마이저가 알고 있다.
- 즉, 인덱스 생성 시점에 오름차순 또는 내림차순으로 정렬이 결정되지만 쿼리가 그 인덱스를 사용하는 시점에 인덱스를 읽는 방향에 따라 오름차순 또는 내림차순 정렬 효과를 얻을 수 있다.

**내림차순 인덱스(”???, 일단 스킵, 어려움)**

- 실제  칼럼이 내림차순인지 오름차순인지는 관계 없다.
- 쿼리가 인덱스를 읽는 순서에 맞으면 정순, 반대면 역순이다.
- 인덱스 오름차순, 쿼리: 오름차순: 정순
- 인덱스 오름차순, 쿼리: 내림차순: 역순
- 인덱스 내림차순, 쿼리: 내림차순: 정순
- 인덱스 내림차순, 쿼리: 오름차순: 역순

- 역순 정렬 쿼리가 정순 정렬 쿼리보다 28% 더 걸린다.
- 차이가 나는 이유는 다음과 같다.
1. 페이지 잠금이 인덱스 정순 스캔에 적합한 구조
2. 페이지 내에서 인덱스 레코드가 단방향으로만 연결된 구조

[MySQL Ascending index vs Descending index](https://tech.kakao.com/2018/06/19/mysql-ascending-index-vs-descending-index/)

- 쿼리에서 자주 사용되는 정렬 순서대로 인덱스를 생성하는 것이 병목 현상 완화에 도움이 된다.

## 8.3.7 B-Tree 인덱스의 가용성과 효율성

- where, group by, order by 절이 어떤 경우에 인덱스를 잘 태울 수 있는지 잘 알아야 한다.

### 8.3.7.1 비교 조건의 각 종류와 효율성

- 다중 칼럼 인덱스에서 각 칼럼의 순서와 그 칼럼에 사용된 조건이 동등 비교(”=”)인지 아니면 크다(”>”) 또는 작다(”<”) 같은 범위 조건인지에 따라 각 인덱스 칼럼의 활용 형태가 달라지며, 그 효율 또한 달라진다.

```sql
select * from dept_emp
where dept_no='d002' and emp_no >= 10114;
```

- 케이스 A: INDEX(dept_no, emp_no)

```sql
select * from dept_emp
where emp_no >= 10114 and dept_no='d002'
```

- 케이스 B: INDEX(emp_no, dept_no)

- 케이스 A는 효율적인 인덱스를 태운다
    - 읽은 레코드가 **모두 사용자가 원하는 데이터**이기 때문이다.
- 케이스 B는 비효율적인 인덱스를 태운다.
    - dept_no가 ‘d002’가 아닌 것은 버려야 된다.
    - 이처럼 나머지 조건에 맞는지 비교하는 작업을 ‘필터링’이라고 한다.

- 케이스 A와 같이 작업의 범위를 결정하는 조건을 ‘작업 범위 결정 조건’이라고 한다.
    - dept_no, emp_no 둘다 작업 범위 결정 조건
- 케이스 B는 dept_no=’d002’ 와같이 비교 작업의 범위를 줄이지 못하는 것을 필터링 조건 또는 체크 조건이라고 표현한다.
    - emp_no만 작업범위 결정 조건, dept_no는 필터링 조건

### 8.3.7.2 인덱스의 가용성

- B-Tree 인덱스의 특징은 왼쪽 값에 기준해서 오른쪽 값이 정렬돼 있다.
    - 하나의 칼럼에서 왼쪽 부터 정렬
    - 두개 이상의 칼럼에서 왼쪽 칼럼부터 정렬

```sql
// first_name이 인덱스
select * from employees where first_name like '%mer';
```

- 위와 같은 쿼리는 인덱스 레인지 스캔 방식으로 인덱스를 이용할 수 없다.
- 왼쪽부터 비교할 수 없기 때문이다.

```sql
// (dept_no, emp_no) 인덱스
select * from dept_emp where emp_no >= 10144;
```

- 인덱스의 왼쪽 값 규칙은 group by 절이나 order by 절 똑같이 적용된다.

### 8.3.7.3 가용성과 효율성 판단

- 아래 케이스는 작업 범위 결정 조건으로 사용할 수 없다.
- 경우에 따라서 체크 조건으로는 사용할 수 있따.

**NOT-EQUAL 비교**

**like ‘%??’ 형태의 문자열 패턴 비교**

**스토어드 함수나 다른 연산자로 인덱스 칼럼이 변형된 후 비교**

**NOT-DETERMINISTIC 속성의 스토어드 함수가 비교 조건에 사용된 경우**

**데이터 타입이 서로 다른 비교**

**문자열 데이터 타입의 collation이 다른 경우**

- 다른 DBMS와는 달리 mysql에선 null 값도 인덱스에 저장된다.
- 그래서 where 조건도 작업 범위 결정 조건으로 인덱스를 사용한다.

```sql
where column is null ..
```

- 다중 칼럼 예시

```sql
index ix_test (column_1, column_2, column_3, .., column_n)
```

- 작업 범위 결정 조건으로 인덱스를 사용하지 못하는 경우
    - column_1 칼럼에 대한 조건이 없는 경우
    - column_1 칼럼의 비교 조건이 위의 인덱스 사용 불가 조건 중 하나인 경우
- 작업 범위 결정 조건으로 인덱스를 사용하는 경우(i는 2보다 크고 n보다 작음)
    - column_1 ~ column_(i-1) 까지 동등 비교 형태(’=’ 또는 ‘in’)
    - column_i 칼럼에 대해 다음 연산자 중 하나로 비교
        - 동등비교(’=’ 또는 ‘in’)
        - 크다 작다(> 또는 <)
        - like로 좌측 일치 패턴(like ‘승환%’)
- 위으 두자기 조건을 모두 만족하는 쿼리는 column_1 부터 column_i 까지 작업 범위 결정 조건
- column_(i+1) ~ column_n은 체크 조건

- 대표적인 것들

```sql
// 인덱스사용 불가능
where column1 <> 2

// 1 ~ 2 범위
where column1 = 1 and column 2 > 10

// 1 ~ 3 범위
column_1 in (1,2) and column2 = 2 and column3 <= 10

// 1 ~ 3 범위 / 4 체크
column_1 = 1 and column2 = 2 and column3 in (10,20,30) and column4 <> 100

// 1 ~ 4 범위 
column1 = 1 and column2 in (2,4) and column3 = 30 and column4 like '김승%'

// 1 ~ 5 범위
column1 = 1 and column2 = 2 and column3 = 30 column4 = '김승환' and column5 = '서울'
```

# 8.4 R-Tree 인덱스
- MySQL에는 공간 인덱스라는 개념이 존재한다. 
- 이는 R-Tree 인덱스 알고리즘을 이용하여 2차원의 데이터를 인덱싱하고 검색하는 목적의 인덱스다. 
- 기본적으로 B-Tree와 비슷하다. B-Tree는 인덱스를 구성하는 컬럼의 값이 1차원의 스칼라 값인 반면, R-Tree 인덱스는 2차원 공간 개념 값이라는 것이다.
- MySQL의 공간 확장에는 다음과 같이 크게 세 가지 기능이 포함돼 있다.

1. 공간 데이터를 저장할 수 있는 데이터 타입
2. 공간 데이터의 검색을 위한 공간 인덱스(R-Tree 알고리즘)
3. 공간 데이터의 연산 함수

## 8.4.1 구조 및 특성
- MySQL은 공간 정보의 저장 및 검색을 위해 여러 가지 기하학적 도형 정보를 관리할 수 있는 데이터 타입을 제공한다. 
  - POINT, LINESTRING, POLYGON, GEOMETRY 등이 있다. GEOMETRY는 나머지 3개 타입의 슈퍼 타입
- 공간 정보의 검색을 위한 R-Tree 알고리즘을 이해하려면 MBR이라는 개념을 알고 있어야 한다. 
- MBR은 Minimum Bounding Rectangle의 약자로, 공간 데이터를 포함하는 가장 작은 사각형을 의미한다. 
- 이 MBR을 이용하여 공간 데이터를 인덱싱하고 검색하는 것이 R-Tree 알고리즘이다.

## 8.4.2 R-Tree 인덱스의 용도
- R-Tree는 위도, 경도 좌표나 CAD 소프트웨어 또는 회로 디자인 등과 같이 좌표 시스템에 기반을 둔 정보에 대해서는 모두 적용할 수 있다.

# 8.5 전문 검색 인덱스
- 문서의 내용 전체를 인덱스화해서 특정 키워드가 포함된 문서를 검색하는 전문 검색에는 InnoDB나 MyISAM에서 제공하는 B-Tree을 사용할 수 없다. 
- 문서 전체에 대한 분석과 검색을 위한 인덱싱 알고리즘을 전문 검색 인덱스라고 한다.

## 8.5.1 인덱스 알고리즘
- 전문 검색에서는 문서 본문의 내용에서 사용자가 검색하게 될 키워드를 분석해 내고, 빠른 검색용으로 사용할 수 있게 이러한 키워드로 인덱스를 구축한다.
- 크게 어근 분석과 n-gram 알고리즘을 이용한 방법이 있다.

## 8.5.1.1 어근 분석 알고리즘
- MySQL 서버의 전문 검색 인덱스는 다음과 같은 두 가지 중요한 과정을 거쳐 색인 작업이 수행된다.
  - 불용어 처리
  - 어근 분석 불용어 처리는 문서에서 검색에 사용할 수 없는 단어를 제거하는 과정이다. 어근 분석은 검색어로 선정된 단어의 뿌리인 원형을 찾는 작업이다.

## 8.5.1.2 n-gram 알고리즘
- n-gram 알고리즘은 단순히 키워드를 검색해내기 위한 인덱싱 알고리즘이다. n-gram은 본문을 무조건 몇 글자씩 잘라서 인덱싱하는 방법이다.

## 8.5.1.3 불용어 변경 및 삭제
- 불용어 처리는 사용자에게 도움이 되기보다는 사용자를 더 혼란스럽게 하는 기능일 수도 있다. 
- 그래서 불용어 처리 자체를 완전히 무시하거나 MySQL 서버에 내장된 불용어 대신 사용자가 직접 불용어를 등록하는 방법을 권장한다.
- 불용어 처리를 무시하는 방법은 두 가지가 있다.
1. 스토리지 엔진에 관계없이 MySQL 서버의 모든 전문 검색 인덱스에 대해 불용어를 완전히 제거한다.
2. InnoDB 스토리지 엔진을 사용하는 테이블의 전문 검색 인덱스에 대해서만 불용어 처리를 무시할 수도 있다.
- 사용자가 직접 정의한 불용어를 사용할 수동 있다.
1. 불용어 목록을 파일로 저장하고, 이 파일을 MySQL 서버에 등록하는 방법
2. InnoDB 스토리지 엔진을 사용하는 테이블의 전문 검색 인덱스에 대해서만 사용할 수 있는 불용어의 목록을 테이블로 저장하는 방식

## 8.5.2 전문 검색 인덱스의 가용성
- 전문 검색 인덱스를 사용하려면 반드시 다음 두 조건을 갖춰야 한다.
1. 쿼리 문장이 전문 검색을 위한 문법을 사용
2. 테이블이 전문 검색 대상 칼럼에 대해서 전문 인덱스 보유

# 8.6 함수 기반 인덱스
- 일반적으로 인덱스는 칼럼의 값 일부 또는 전체에 대해서만 인덱스 생성이 허용된다. 
- 하지만 떄로는 칼럼의 값을 변형해서 만들어진 값에 대해 인덱스를 구축해야 할 때도 있는데, 이런 경우에는 함수 기반 인덱스를 사용한다.
1. 가상 칼럼을 이용한 인덱스
2. 함수를 이용한 인덱스

## 8.6.1 가상 칼럼을 이용한 인덱스
```sql
CREATE TABLE `employees` (
  `first_name` varchar(14) NOT NULL,
  `last_name` varchar(16) NOT NULL,
  `full_name` varchar(32) GENERATED ALWAYS AS (concat(`first_name`,' ',`last_name`)) VIRTUAL,
  PRIMARY KEY (`emp_no`),
  KEY `idx_full_name` (`full_name`)
);
```
- 위 처럼 가상 칼럼을 이용한 인덱스를 생성하면, full_name 칼럼에 대한 인덱스가 생성된다. 
- 하지만 이 방법은 새로운 칼럼을 추가하는 것과 같은 효과를 내기 때문에 실제 테이블의 구조가 변경된다는 단점이 있다.

## 8.6.2 함수를 이용한 인덱스
```sql
CREATE TABLE `employees` (
  `first_name` varchar(14) NOT NULL,
  `last_name` varchar(16) NOT NULL,
  PRIMARY KEY (`emp_no`),
  KEY `idx_full_name` ((concat(`first_name`,' ',`last_name`)))
);
```
- 함수를 직접 사용하는 인덱스는 테이블의 구조는 변경하지 않고, 계산된 결괏값의 검색을 빠르게 만들어준다.

# 8.7 멀티 밸류 인덱스
- 전문 검색 인덱스를 제외한 모든 인덱스를 레코드 1건이 1개의 인덱스 키 값을 가진다. 
- 즉, 인덱스 키와 데이터 레코드는 1:1의 관계를 가진다. 하지만 멀티 밸류 인덱스는 하나의 데이터 레코드가 여러 개의 키 값을 가질 수 있는 형태의 인덱스다. 
- 일반적인 DBMS를 기준으로 생각하면 이러한 인덱스는 정규화에 위배되는 형태다. 
  - 하지만 최근 RDBMS들이 JSON 데이터 타입을 지원하기 시작하면서 JSON의 배열 타입의 필드에 저장된 원소들에 대한 인덱스 요건이 발생한 것이다.

# 8.8 클러스터링 인덱스

- mySQL 서버에서 클러스터링은 테이블의 레코드를 비슷한 것(프라이머리 키를 기준으로)들끼리 묶어서 저장하는 형태로 구현되는데, 이는 주로 비슷한 값들을 동시에 조회하는 경우가 많다는 점에 착안
- InnoDB 에서만 지원

## 8.8.1 클러스터링 인덱스

- 테이블의 PK에만 적용
- PK 값이 비슷한 레코드끼리 묶어서 저장하는 형태
- 중요한 점은 PK 값에 의해 레코드의 저장 위치가 결정됨
- 또한 PK 값이 변경되면 레코드의 물리적인 저장 위치가 바뀌어야 한다
- 따라서, PK를 신중히 결정해야 한다.
- PK 기반의 검색은 매우 빠르나, PK 저장이나 수정에 대한건 상대적으로 느리다.

```
일반적으로 B-Tree 인덱스도 인덱스 키값으로 이미 정렬되어 저장된다. 이 또한 인덱스의 키 값으로 클러스터링된 것으로 생각할 수 있다.
 하지만 클러스터링 인덱스라 부르지 않는데 이유는 **테이블의 레코드가 PK 값으로 정렬되어 저장된 경우만** 클러스터링 인덱스라 부르기 때문이다.
```

- 구조 자체는 일반 B-Tree와 비슷하다.
- 다른점은 **리프 노드에 모든 칼럼이 같이 저장돼 있다.**
- 자체가 하나의 거대한 인덱스 구조로 관리된다.

- 위 구조에서 아래 쿼리를 실행하면 어떻게 될까?

```sql
update tb_test set emp_no = 100002 where emp_no = 100007;
```

- 페이지 3의 100007이 페이지 2로 이동한다. (물론 정렬된 상태는 유지)
- 페이지3에서 제거 후 페이지2에 추가

- 프라이머리 키가 없는 InnoDB 테이블은 다음 우선순위 대로 PK 를 선택한다.
1. 프라이머리 키가 있으면 기본적으로 PK를 클러스터링 키로 선택
2. NOT NULL 옵션의 유니크 인덱스 중에서 첫번째 인덱스를 클러스터링 키로 선택
3. 자동으로 유니크한 값을 가지도록 증가되는 칼럼을 내부적으로 추가한 후, 클러스터링 키로 선택
    1. 개발자가 컨트롤 불가능

- InnoDB 테이블에서 클러스터링 인덱스는 테이블 당 단 하나만 가질 수 있는 엄청난 혜택이므로 가능하다면 프라이머리 키를 명시적으로 생성하자.

## 8.8.2 세컨더리 인덱스에 미치는 영향

- MyISAM이나 MEMORY 테이블 같은 클러스터링 되지 않은 테이블은 insert 될 때 처음 저장된 공간에서 절대 이동하지 않는다.
- 데이터 레코드가 저장된 주소는 내부적인 레코드 아이디(ROWID) 역할을 한다.
- PK나 세컨더리 인덱스의 각 키는 그 주소를 이용해 실제 데이터 레코드를 찾아온다.
- 그래서 MyISAM 테이블이나 MEMORY 테이블에서는 PK 키와 세컨더리 인덱스는 구조적으로 아무런 차이가 없다.

```text
ROWID; 테이블 각 레코드(행)이 가지고 있는 고유의 주소
```

- InnoDB 테이블에서 세컨더리 인덱스가 실제 레코드가 저장된 주소를 가지고 있다면 어떻게 될까?
- **클러스터링 키값이 변경될 때마다 데이터 레코드의 주소가 변경되고 그때마다 해당 테이블의 모든 인덱스에 저장된 주솟값을 변경해야 한다.**

- 검색하는 과정에서 MyISAM과 InnoDB와 어떤 차이가 있는지 한번 살펴보자
- MyISAM: 인덱스를 검색해서 레코드의 주소를 확인한 후, 레코드의 주소를 이용해 최종 레코드를 가져옴
- InnoDB: 인덱스를 검색해 레코드의 프라이머리 키값을 확인한 후, 프라이머리 키 인덱스를 검색해서 최종 레코드를 가져옴

## 8.8.3 클러스터링 인덱스의 장점과 단점

- MyISAM과 같은 클러스터링 되지 않은 일반 PK 키와 클러스터링 인덱스를 비교했을 때 장단점을 보자

### 장점

- PK(클러스터링 키)로 검색할 때 처리 성능이 매우 빠르다.
    - 특히 PK를 범위 검색하는 경우 매우 빠름
- 테이블의 모든 세컨더리 인덱스가 프라이머리 키를 가지고 있기 때문에 인덱스만으로 처리될 수 있는 경우가 많다.(커버링 인덱스)

### 단점

- 테이블의 모든 세컨더리 인덱스가 클러스터링 키를 갖기 때문에 클러스터링 키값의 크기가 클 경우 전체적으로 인덱스의 크기가 커진다.
- 세컨더리 인덱스를 통해 검색할 때 프라이머리 키로 다시 한번 검색해야 하므로 처리 성능이 느리다.
- INSERT 할 때 프라이머리 키에 의해 레코드의 저장 위치가 결정되기 때문에 처리 성능이 느리다.
- 프라이머리 키를 변경할 때 레코드를 delete 하고 insert 하는 작업이 필요하기 때문에 처리 성능이 느리다.

## 8.8.4 클러스터링 테이블 사용시 주의 사항

### 8.8.4.1 클러스터링 인덱스 키의 크기

- 모든 세컨더리 인덱스가 pk 값을 포함하기 때문에, pk의 크기가 커지면 세컨더리 인덱스도 자동으로 커진다.
- 5개의 세컨더리 인덱스를 가지는 테이블의 pk가 10바이트 VS 50바이트 비교

- 100만건이 190MB 차이나고
- 1000만건은 1.9GB가 차이난다.

### 8.8.4.2 PK는 AUTO-INCREMENT보다는 업무적인 칼럼으로 생성(가능한 경우) (이해 안감)

- innoDB의 PK는 클러스터링 키로 사용되며, 이 값에 의해 레코드의 위치가 결정된다.
- PK로 검색하는 경우 클러스터링되지 않은 테이블에 비해 매우 빠르게 처리된다.
- 칼럼의 크기가 크더라도 업무적으로 해당 레코드를 대표할 수 있다면 PK로 설정하는 것도 좋다 (?)

### 8.8.4.3 pk는 반드시 명시할 것

- 가능하면 auto-inr 라도 이용해서 생성을 권장한다.
- PK를 정의하지 않으면 내부적으로 일련번호 칼럼을 자동으로 추가하지만, 사용자가 사용할 수가 없다.
- 생성하든 안하든 똑같다면 우리가 사용할 수 있도록 auto-inc라도 설정하자.
- 번외로 row 기반의 복제나 innodb 클러스터에서는 모든 테이블이 pk를 가져야만 하는 정상적인 복제 성능을 보장하기도 한다.
    - 마스터에서 변ㄱ여된 각 레코드가 PK를 기준으로 식별한다.
    - PK가 없으면 특정 행을 효율적으로 식별하고 세컨더리에 복제하는데 성능이 떨어질 수 있다.
        - 왜? PK는 고유하기 때문에 세컨더리에서 즉각적으로 찾을 수 있다.

### 8.8.4.4 auTO-INCREMENT 칼럼을 인조 식별자로 사용할 경우

- 세컨더리 인덱스가 필요 없다면 PK 크기가 길어도 상관없다.
- 하지만 인덱스도 필요하고 키의 크기도 길다면 auto-inc를 pK로 설정해라(=인조키)
- INSERT만 하는 로그성 테이블은 인조키(auto-inc)가 성능 향상에 도움이 된다.
    - PK가 규칙성있게 순차적으로 증가하기 때문에 페이지 분할이 최소화 됩니다.
        - 단지 새 페이지에 PK가 할당될 뿐입니다.
    - 여러 삽입 작업이 서로 간섭할 가능성이 적다.

# 8.9 유니크 인덱스

- 유니크 인덱스는 같은 값이 2개 이상 저장될 수 없음을 나타내는 제약 조건의 의미에 가깝다.
- 참고로 NULL은 2개 이상 저장될 수 있다.
- PK는 기본적으로 유니크 속성이 자동으로 부여된다. (유니크 인덱스가 부여되는 건 아니다)

## 8.9.1 유니크 인덱스와 일반 세컨더리 인덱스 비교

- 8.9.1 유니크 인덱스와 일반 세컨더리 인덱스는 구조상 아무런 차이가 없다.

### 8.9.9.1 인덱스 읽기

- 일반 세컨더리 인덱스보다 유니크 인덱스가 더 빠르다고 생각하는데 아니다.
- 유니크하지 않은 세컨더리 인덱스는 중복된 값이 허용 되므로 읽어야 할 레코드가 많아서 느린거지. 인덱스 자체의 특성 때문에 느린 건 아니다.
- 읽어야 하는 레코드 건수가 같다면 두개의 성능 차이는 미미하다.

### 8.9.9.1 인덱스 쓰기

- 유니크 인덱스는 쓰기작업을 할 때 중복된 값의 유무를 체크하는 과정이 필요하기 때문에 세컨더리 인덱스의 쓰기보다 느리다.
    - 중복 체크를 해야 해서 작업 자체도 버퍼링하지 못하고 즉시 처리해야 한다.
- 유니크 인덱스는 중복된 값을 체크할 때는 읽기 잠금, 쓰기를 할때는 쓰기 잠금을 사용하는데 이 과정에서 데드락이 빈번히 발생한다.

## 8.9.2 유니크 인덱스 사용시 주의사항

- 성능이 좋아질 거라 기대하고 유니크 인덱스를 생성하지 마라
- 같은 칼럼에 유니크 인덱스와 일반 인덱스를 중복해서 생성할 필요가 없다.
    - 유니크 인덱스는 일반 인덱스와 같은 역할을 수행하기 때문이다.
- 같은 칼럼에 PK와 유니크 인덱스도 불필요한 중복이다.

- 결론은 유일성이 꼭 보장돼야 하는 칼럼에는 유니크 인덱스를 생성하고, 필요하지 않다면 유니크하지 않은 세컨더리 인덱스를 생성해라.

# 8.10 외래키

- InnoDB 에만 외래키를 생성할 수 있다.
- 외래키 제약이 설정되면 자동으로 연관되는 테이블의 칼럼에 인덱스까지 생성된다.
- 외래키가 제거되지 않은 상태에서는 자동으로 생성된 인덱스를 삭제할 수 없다.
- 외래키 관리의 특징
    - 테이블의 변경(쓰기 잠금)이 발생하는 경우에만 잠금 경합(잠금 대기)이 발생한다.
    - 외래키와 연관되지 않은 칼럼의 변경은 최대한 잠금 경합(잠금 대기)을 발생시키지 않는다.

## 8.10.1 자식 테이블의 변경이 대기하는 경우

1. 1번 커넥션 부모에서 id 2인 레코드 update (쓰기잠금 획득)
2. 2번 커넥션 자식에서 외래키 2를 100으로 update 시도시 1번 커넥션의 변경 작업이 완료될 때 까지 대기

## 8.10.2 부모 테이블의 변경 작업이 대기하는 경우

1. 1번 커넥션에서 자식에서 외래키 1을 가지고 있는 레코드를 변경 (쓰기 잠금 획득)
2. 2번 커넥션 부모에서 id가 1인 레코드를 삭제하는 경우 1번 커넥션의 변경 작업이 완료될 때 까지 대기

- 자식 테이블에 레코드 추가시 외래키가 부모 테이블에 있는지 확인하는 s-lock을 건다.
- 즉, 외래키를 사용하면 잠금이 다른 테이블로 확장되므로 동시성에 영향을 줄 수 있다.
