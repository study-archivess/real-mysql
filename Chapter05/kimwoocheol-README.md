# 트랜잭션과 잠금

- 트랜잭션은 작업의 완전성을 보장해 주는것이다.
- 잠금과 트랜잭션은 목적이 다르다.
  - 잠금은 동시성을 제어하기 위한 기능이다.
  - 트랜잭션은 데이터의 정합성을 보장하기 위한 기능이다.
- 격리수준은 여러 트랜잭션 간의 작업 내용을 어떻게 공유하고 차단할 것인지 결정하는 레벨이다.

## 트랜잭션

### MySQL에서의 트랜잭션
- 트랜잭션은 쿼리 수의 관계 없이 논리적인 작업 셋 자체가 100% 적용되거나 아무것도 적용되지 않아야 함을 보장해 주는 것이다.(ACID의 A)

```sql
mysql> create table tb_tab_myisam(col int primary key) ENGINE=MyISAM;
mysql> insert into tb_tab_myisam values (3);

mysql> create table tb_tab_innodb(col int primary key) ENGINE=InnoDB;
mysql> insert into tb_tab_innodb values (3);

mysql> insert into tb_tab_myisam values(1),(2),(3);
Error Code: 1062. Duplicate entry '3' for key 'tb_tab_myisam.PRIMARY'
mysql> insert into tb_tab_innodb values(1),(2),(3);
Error Code: 1062. Duplicate entry '3' for key 'tb_tab_innodb.PRIMARY'

-- MyISAM
mysql> select * from tb_tab_myisam;
+-----+
| col |
+-----+
|   1 |
|   2 |
|   3 |
+-----+

-- InnoDB
mysql> select * from tb_tab_innodb;
+-----+
| col |
+-----+
|   3 |
+-----+
```
- 테이블에 3이 있는 상태에서 1, 2, 3을 동시에 삽입하는 쿼리다.
- MyISAM과 InnoDB 모두 Insert 과정에서 `Duplicate entry '?' for key(1062)` 에러가 발생한다.
- 다만 스토리지 엔진 레벨에 따라 테이블의 결과는 다르다.

- InnoDB는 1,2,3 모두 삽입되지 않았다. 앞에서 말한 원자성이 지켜진 것이다.
- MyISAM 테이블은 PK가 3인 데이터를 삽입 시도시 1062 에러가 발생했지만 1,2는 INSERT되어 있다.
    - 이러한 현상을 Partial Update 라고 표현한다.
- Partial Update 현상을 막기 위해 IF..ELSE 구문이 들어간 프로그램 로직을 짜야 한다.
- InnoDB는 아래와 같이 간단하게 구현 가능하다.

```sql
    try {
      start transaction;
      insert into tab_a ..;
      insert into tab_b ..;
      commit;
    } catch(exception {
       rollback;
    }
```

### 주의사항
- 트랜잭션은 DBMS의 커넥션과 동일하게 꼭 필요한 최소의 코드에만 적용하는 것이 좋다.
- 즉, 프로그램 코드에서 트랜잭션의 범위를 최소화 하자.

- 게시판에 게시물 작성 후 저장버튼을 눌렀을 때 서버에서 처리하는 내용 예시
```text
1) 처리시작 
  =>  DB 커넥션 생성
  =>  트랜잭션 시작
2) 글쓰기 글자수 제한 확인 
3) 사용자 글쓰기 권한 확인 
4) 첨부된 파일의 업로드 가능 확장자 및 용량 확인 , 저장 
5) 사용자 입력 내용(글 과 첨부파일 정보) DB에 저장  ## DB INSERT
6) 저장 된 내용 조회 및 추가 정보 DB에서 조회 
7) 게시물에 대한 알림 메일 발송  ## 외부 API
8) 메일 발송 이력 DB에 저장  ## DB INSERT
  <= 트랜잭션 종료  
  <= DB 커넥션 반납
10) 처리 완료
```
- 위 내용에서 좋지 않은 부분은 트랜잭션으로 묶인 많은 단계 중에서 실제 DB에 저장하는 단계는 5번(사용자 입력 내용 DB에 저장)이다.
- 따라서, 그 앞단의 부분은 포함시키지 않아도 된다.
- 더 큰 위험은 7번( 메일 발송)이다. 외부 통신 작업은 트랜잭션에서 반드시 제거해야 한다.
- 외부 로직에서 문제가 발생되어 Pending이나 장시간 소요되면 전체적인 처리가 매우 늦어지거나 문제가 될 수 있다.
- 또 다른 문제는 8번에서 예외가 발생하여 트랜잭션 롤백이 일어났을 때, DB에 저장되지 않지만 메일은 전송된다.

- 업무 특성과 구현이 필요한 로직에 따라 트랜잭션 설계가 다양한 방면으로 작성될 수 있다.
- 기본적으로 애플리케이션 코드에서 DB의 커넥션을 가지고 있는 범위, 그리고 트랜잭션이 활성화 되어 있는 프로그램의 범위는 최소화 해야 한다.

- 책에서 보완한 부분은 아래와 같다.
```text
트랜잭션 예시
1) 처리시작 
2) 글쓰기 글자수 제한 확인 
3) 사용자 글쓰기 권한 확인 
4) 첨부된 파일의 업로드 가능 확장자 및 용량 확인 , 저장 
  =>  DB 커넥션 생성
  =>  트랜잭션 시작
5) 사용자 입력 내용(글 과 첨부파일 정보) DB에 저장 
  <= 트랜잭션 종료 
6) 저장 된 내용 조회 및 추가 정보 DB에서 조회 
7) 게시물에 대한 알림 메일 발송 
  =>  트랜잭션 시작
8) 메일 발송 이력 DB에 저장 
  <= 트랜잭션 종료
  <= DB 커넥션 반납
10) 처리 완료
```
- 7번 같은 경우 비동기 논블로킹을 사용하여 결과를 콜백으로 받은뒤, 명시적 트랜잭션을 사용하여 8번을 수행하면 되지 않을까? 나중에 직접 구현해서 테스트 해봐야겠다.
- 이메일 전송 실패 케이스는 다음과 같은 케이스가 있을 것 같다.
  - 전송하자 마자 Exception 발생
  - 지정된 타임아웃 초과

### 트랜잭션의 4가지 특성(ACID)
- 트랜잭션의 4가지 특성을 다시한번 짚고 넘어가자

#### Atomicity(원자성)
- ‘all or noting’ 특성
- 트랜잭션이 모든 연산들이 정상적으로 수행 완료되거나 혹은 어떠한 연산도 수행되지 않은 상태를 보장해야 하는 특성

#### Atomicity(일관성)
- 트랜잭션이 성공적으로 수행된 후 DB가 일관성 있는 상태를 유지하는 특성
- DB의 일관성이란 어떤것 일까?
  - 제약조건을 포함한 모든 정의된 조건에 맞게 데이터가 입력 및 변경되어야 하는 것
    - 기본키 제약조건, 외래키 제약조건 Cascade 등
  - 또한, 트랜잭션이 실패하면 트랜잭션 처리 이전의 상태로 롤백도 일관성을 보장하는 것으로 볼 수 있다.

#### Isolation(독립성/고립성)
- 여러 트랜잭션이 동시에 수행되더라도 각각의 트랜잭션은 다른 트랜잭션에 영향을 받지 않고 독립적으로 수행되어야 함을 의미한다.
- 수행되는 트랜잭션이 완료될 때 까지 다른 트랜잭션이 끼어 들지 못하게 하여 데이터 누락이나 잘못된 데이터에 대한 방지를 하는 것이다.

#### Durability(지속성)
- 트랜잭션이 성공하여 커밋 되었다면, 해당 트랜잭션에 의한 반영된 모든 변경은 어떠한 장애가 발생하더라도 보존되어야 한다.

## MySQL 엔진의 잠금
- MySQL에서 사용 되는 잠금은 크게 MySQL 엔진 레벨과 스토리지 엔진 레벨로 나눌 수 있다.
- MySQL 엔진 레벨의 잠금은 모든 스토리지 엔진에 영향을 미치지만, 스토리지 엔진 레벨의 잠금은 스토리지 엔진간 상호 영향을 미치지 않는다.
- MySQL 엔진 락 종류
  - 테이블 락: 테이블 데이터 동기화 목적
  - 메타 데이터 락(Metadata Lock) : 테이블 구조를 잠금
  - 네임드 락:  사용자의 필요에 따라 사용

### 글로벌 락
- 글로벌 락은 `FLUSH TABLES WITH READ LOCK` 명령으로 획득할 수 있으며, MySQL이 제공하는 잠금 가운데 가장 범위가 크다.
- 한 세션에서 글로벌 락을 획득하면 다른 세션에서 SELECT를 제외한 대부분의 DDL과 DML 문장은 해당 글로벌 락에 의해서 대기를 하게 된다.
- 글로벌 락이 영향을 미치는 범위는 MySQL 서버 전체 대상이며, 작업 대상 테이블이나 DB가 다르더라도 동일하게 영향을 미치게 된다.
- mysqldump  툴 사용시 백업 받을 스토리지 엔진의 종류에 따라 옵션값을 달리한다.
  - mysqldump 툴을 통해 InnoDB만 백업하면 —single-transaction 옵션 사용
    - 참고로 MyISAM은 트랜잭션을 지원하지 않기 때문에 —single-transaction을 사용해도 일관성이 보장되지 않는다.
  - mysqldump 툴을 통해 다양한 스토리지 엔진을 백업하면 —lock-all-tables 옵션 사용, 글로벌 락 사용
  - --lock-tables이 디폴트 옵션. 테이블에 순차적으로 락을 걸고 해제한다. 스토리지 종류 상관없이 가능

- 글로벌 락을 실행하기 전에 테이블이나 레코드에 쓰기 잠금을 거는 SQL이 실행 중이라면 해당 SQL 트랜잭션이 완료 될때 까지 기다려야 한다
- 또한, 테이블에 읽기 잠금을 거는 과정에서 먼저 테이블을 FLUSH 해야 하기 때문에 테이블에 실행 중인 모든 종류의 쿼리가 완료 되어야 한다.

- mysqldump를 이용해 백업을 수행시 사용하는 옵션에 따라 MySQL 서버에 사용되는 잠금이 다르다.
- `—single-transaction`을 사용할 경우(InnoDB 에서만 가능) InnoDB Storage 엔진의 테이블은 잠금을 걸지 않는다.
  - 벡업을 하기 전에 해당 세션의 격리 수준을 `REPEATABLE READ`로 변경후 `START TRANSACTION`을 실행한다.
  - 격리수준이 `REPEATEABLE READ`고 하나의 트랜잭션 안에서 이루어지기 때문에 데이터 일관성이 보장된다.
  - MVCC 구조로 인해 다른 커넥션에서 insert, update, delete 명령어를 사용할 수 있다.
  - 주의점 으로는 백업 수행중에다음 명령어를 사용하면 안된다. mysqldump에서 수행한 select가 테이블 내용 검색시 잘못된 내용을 가져오거나 실패할 수 있다.
    - alter table
    - create table
    - drop table
    - rename table
    - truncate table

```text
💡 mysqldump
적은 양의 데이터를 백업할 때 가장 간편하게 사용할 수 있는 MySQL 백업 도구
MySQL Client가 설치되어 있어야 한다.

중요 옵션
--lock-all-tables: 모든 테이블에 대해 읽기 락을 건다.

-l, --lock-tables(디폴트 옵션): 각각의 테이블에 대해 읽기 락을 걸고 해제 하는 방식이다. 각 테이블을 덤프하기전에 락을 걸고 덤프가 끝나면 락을 해제한다.--skip-lock-tables로 락 대상에서 제외할 테이블을 지정도 가능하다. innodb만 백업할 경우 —single-transaction 옵션 추천
문제점: 순차적으로 하기 때문에 mysqldump 진행 도중 백업이 완료된 테이블에 insert,update,delete 한건은 반영되지 않는다.

—quick: 백업할 행 데이터 전체를 한 번에 읽어서 백업한다. 해당 옵션을 사용하지 않으먼 백업 파일에 기록하기 전에 메모리에 먼저 버퍼링하고 백업이 수행되므로 소요 시간이 길어질 수 있다. 백업 대상 테이블 크기가 크면 —single-transaction 옵션과 함께 사용하면 좋다
```

- MySQL 8.0 부터는 InnoDB 스토리지 엔진이 기본으로 되었고, 조금 더 가벼운 글로벌 락의 필요성이 생기게 되었다.
- 그래서 Xtrabackup 또는 Enterprise Backup과 같은 백업 툴에서 안정적인 실행을 위한 백업 락이 도입됐다

```sql
LOCK INSTANCE FOR BACKUP;
-- // 백업 실행
UNLOCK INSTANCE;
```
- 해당 명령어를 사용하기 위해선 BACKUP_ADMIN 권한이 필요하다.
- 여러 세션이 동시에 백업 잠금을 보유할 수 있다.

- 특정 세션에서 백업락을 획득하면 모든 세션에서 다음과 같은 변경을 할 수 없다.
  - 데이터베이스 및 테이블 등 모든 객체 생성 및 변경, 삭제
  - 레코드 생성, 변경, 제거 안됨
  - REPAIR TABLE과 OPTIMIZA TABLE 명령
    - REPAIR TABLE: 데이터 파일이 손상된 경우 등 손상된 테이블을 복구하는데 사용
    - OPTIMIZA TABLE: 테이블의 저장 공간을 재구성하고, 테이블과 인덱스의 성능을 향상시키는데 사용
  - 사용자 관리 및 비밀번호 변경
  - TRUNCATE TABLE
- 사용자가 만든 임시 테이블의 데이터 변경은 허용된다.
- 또한, 사용자가 만든 임시 테이블을 생성하고, 이름을 바꾸고, 제거할 수 있습니다.

- 백업을 세컨더리 서버에서 수행할 때 Xtrabackup 이나 Enterprise Backup 툴이 실행되는 도중에 스키마 변경이 발생되면 백업이 실패하여 장시간 수행되었던 백업을 처음부터 다시 수행해야 한다.
- 이러한 것을 막기 위해 8.0의 백업락을 사용한다. 정상적으로 복제는 이루어지지만 백업의 실패를 막기 위해 DDL 명령이 실행되면 **복제를 일시 중지**하는 역할을 한다.

```text
💡 복제를 일시중지 하는게 맞나?
찾아보면 백업락을 걸고 ddl을 실행하면 백업이 완료될때 까지 실행되지 않다가, 
백업이 완료된 후 unlock instance를 사용하여 락을 해제하면 대기중이던 ddl 명령이 실행되는거 같기도 한데..
다시한번 찾아봐야 겠다. 
```

- 만약 ddl과 LOCK INSTANCE FOR BACKUP이 동시에 일어나면 DDL 수행을 먼저 기다린 다음 백업 락을 수행한다.
  - 이전에는 DDL이 완료되기 전에 백업락이 해제되어 DDL의 반영이 되지 않은 문제가 있었다.
  - MYSQL 8.0.11에서 버그 패치되엇다.
  - https://dev.mysql.com/doc/relnotes/mysql/8.0/en/news-8-0-11.html
  - https://bugs.mysql.com/bug.php?id=87812

### 테이블 락
- 테이블 락은 개별 테이블 단위로 설정되는 잠금이며, 명시적 또는 묵시적으로 특정 테이블 락을 획득할 수 있습니다.
- 명시적으로 `LOCK TABLES 테이블명 [real | write]` 명령으로 특정 테이블 락을 획득할 수 있습니다.
- 테이블 락은 MyISAM과 InnoDB 스토리지 엔진을 사용하는 테이블 모두 동일하게 설정할 수 있다.
- 명시적으로 획득한 잠금은 `UNLOCK TABLES` 명령으로 잠금을 해제할 수 있다.
- 특별한 경우가 아니라면 애플리케이션에서 사용할 필요는 없다.
- 사용을 하게 되면 글로벌 락과 동일하게 온라인 작업에 상당한 영향을 미친다.

- 묵시적인 테이블 락은 MyISAM이나 MEMORY 테이블에 데이터를 변경하는 쿼리를 실행하면 발생 한다.
- 사용자가 데이터를 변경하면 MySQL 서버는 테이블에 잠금을 설정하고 데이터를 변경한 후 잠금을 해제하는 형태로 사용한다.
- 즉, 묵시적 테이블 락은 쿼리가 실행되는 동안 자동으로 획득 되었다가 쿼리가 완료된 후 자동 해제된다.

- InnoDB 스토리지 엔진 테이블의 경우 대부분의 데이터 변경(DML)은 레코드 기반의 잠금을 사용하고 테이블 레벨의 잠금은 스키마 변경을 막기 위해 사용된다.

### 네임드 락
- `GET_LOCK()` 함수를 이용해 임의의 문자열을 지정하여 잠금을 설정할 수 있는 잠금 기능이다.
  - `RELEASE_LOCK()` 으로 해제할 수 있다.
- 대상 테이블이나 레코드 또는 AUTO_INCREMENT와 같은 DB 객체가 아닌, 단순히 사용자가 지정한 문자열에 대해 잠금을 획득하고 반납하는 잠금 기능이다.

- 네임드락은 자주 사용되지 않는다. 레디스와 같은 솔루션을 통한 분산락을 구현할 수 있기 때문이다.
- 별도의 솔루션이나 인프라 구축 비용을 줄이고 계속 사용중인 DB을 이용한다면 네임드락을 고려할 수 있다.
- 네임드 락은 주로 분산락에서 사용된다.
  - 분산락은 데이터베이스 등 공통된 저장소를 이용해 자원이 사용 중인지를 체크하며 전체 서버에서 동기화된 처리를 구현한다.

### 메타 데이터 락
- 메타데이터 락은 데이터베이스 객체(테이블이나 뷰)의 이름이나 구조를 변경 하는 경우에 획득하는 잠금이다.
- 메타데이터 락은 명시적으로 획득하거나 해제할 수 있는 것은 아니다.
- 상황에 따라서 명시적으로 획득할 수 있다.

아래와 같이 트랜잭션을 명시적으로 시작한 후 데이터를 조회하고 다른 세션에서 테이블의 구조를 변경하게 되면 메타데이터 락으로 대기를 하게 된다.
```sql
-- Session 1
select CONNECTION_ID();
+-----------------+
| CONNECTION_ID() |
+-----------------+
|               4 |
+-----------------+
<-- Session 1의 Process ID 는 4 로 확인됨

-- 트랜잭션 시작
mysql> start transaction;
Query OK, 0 rows affected (0.00 sec)
mysql> select * from user_info;
+----+------+
| id | name |
+----+------+
|  1 | jade |
|  2 | Tom  |
+----+------+
2 rows in set (0.00 sec)

-- ==============================================

-- Session 2 : 컬럼 추가 시도
mysql> alter table user_info add column col2 varchar(100);
<!!--- 락 획득 실패 및 락에 의해 대기중

-- ==============================================

-- Session 1 : Full processlist
mysql> show full processlist;
+----+------------+------+------+---------------------------------+----------------------------------------------------+
| Id | User       | db   | Time | State                           | Info                                               |
+----+------------+------+------+---------------------------------+----------------------------------------------------+
|  2 | system user| NULL | 1321 | Connecting to master            | NULL                                               |
|  4 | root       | npm  |    0 | starting                        | show full processlist                              |
|  8 | root       | npm  |   10 | Waiting for table metadata lock | alter table user_info add column col2 varchar(100) |
+----+------------+------+------+---------------------------------+----------------------------------------------------+
                          <!!-- Metadata lock 에 의해 Session 2가 대기 하는 상황
```
- 즉, 한 세션에서 트랜잭션이 시작되었고 사용중인 테이블(select도 사용중이라 볼 수 있다)은 해당 트랜잭션이 종료되기 전까지 다른 세션에서 ddl을 사용할 수 없다는 것이 포인트다
  - 트랜잭션 내에서 실행되는 모든 쿼리가 일관된 테이블 구조를 보장하기 위해 메타데이터 락을 자동으로 거는것 같다.
- 예를 들어 한 세션에서 트랜잭션을 생성하고 계속 select 하는 와중에서 다른 세션에서 alter문을 실행시 해당 alter문은 select 문이 끝나기 전까지 대기에 빠지게 된다.

- 또한, `RENAME TABLE tb_old to tb_new;` 같이 테이블 이름을 변경하는 경우 자동으로 메타데이터 락을 획득한다.
- 원본이름과 변경될 이름 두개 모두 한꺼번에 잠금을 설정한다.

- 실시간으로 테이블을 RENAME을 해야 할 경우 하나의 RENAME 명령문 안에서 같이 처리하는 방식이 “Table not found”와 같은 상황은 발생되지 않는다.
- 그러나 매우 짧은 시간이라도 RENAME TABLE 구문을 순차적으로 별도로 실행 한다면 아주 짧은 시간에 해당 테이블을 쿼리하는 경우 해당 쿼리의 세션에서는 “Table not found” 오류를 받게 된다.

```text
💡 테이블 create문에서 KEY_BLOCK_SIZE는 어떤 건가요?
인덱스를 압축할 때 사용하는 블록의 크기를 지정한다.
큰 크기를 설정하면 압축률이 낮아지고, 작은 크기를 설정하면 압축률이 높아진다.

압축된 인덱스는 읽기 작업에서 더 적은 I/O를 요구하지만, 압축 해제를 위한 CPU 작업이 필요하다.
```

```text
💡 대용량 테이블에 ddl을 실행하면 언두 로그와 DDL 버퍼 관점에서 어떻게 되는지 설명해주세요.
언두 로그가 증가하는 이유는 DDL 명령으로 인해 데이터를 재구성하는 과정에서 변경전 데이터의 상태를 언두로그에 계속해서 쌓기 때문이다.

DDL 버퍼는 DDL 명령이 처리될 때 필요한 메모리 공간을 제공한다. 대용량 테이블에서는 이 버퍼의 크기가 매우 클 수 있어, 메모리에 부담이 갈 수 있다.
```
- MySQL의 DDL은 단일 스레드로 작동한다.
- 그래서 수백, 수천만건의 데이터가 담긴 테이블에 DDL을 할경우 오랜 시간이 걸린다.
- 더 좋은 방법은 새로운 구조의 테이블을 생성하고 데이터를 옮긴 후 RENAME으로 테이블을 교체하는 방법이 있다.

## MySQL 엔진의 잠금
- InnoDB 스토리지 엔진은 MySQL에서 제공하는 잠금과는 별개로 스토리지 엔진 내부에서 레코드 기반의 잠금 방식을 탑재하고 있다.
- 동시성은 뛰어나지만, 이원화된 잠금 처리로 인해 잠금 정보를 보기가 상당히 까다로웠다.
- 예전에는 `lock_monitor`와 `show engine innodb status` 명령이 전부였다.
  - 이마저도 어셈블리 코드 보는 느낌이 나서 상당히 어려웠다.
- 최근 버전에서는 `information_schema`에서 `innodb_trx, innodb_locks, innodb_lock_waits` 테이블을 조인해서 조회하면 어떤 트랜잭션이 어떤 잠금을 대기하고 있고 해당 잠금을 어느 트랜잭션이 가지고 있는지 확인할 수 있고, 장시간 잠금을 가지고 있는 client를 찾아서 종료시킬 수 있다.
- InnoDB의 잠금에 대한 모니터링도 강화되면서 `performance schema`를 이용해 innodb 스토리지 엔진의 내부 잠금에 대한 모니터링 방법도 추가됐다.

```
로컬에 설치한 mysql 8.0.35에 innodb_trx, innodb_locks, innodb_lock_waits 테이블이 없는것 같다.

찾아보니
MySQL 8.0 부터는 information_schema 의 정보들은 조금씩 제거(Deprecated)되고 있으며, performance_schema 의 data_locks 와 data_lock_waits 테이블로 대체되고 있다고 한다.

https://velog.io/@p0tat0_chip/InnoDB-스토리지-엔진-잠금
```

### InnoDB 스토리지 엔진의 잠금
- nnoDB 스토리지 엔진은 레코드 기반의 잠금 기능을 제공하며, 잠금 정보가 상당히 작은 공간으로 관리되기 때문에 레코드 락이 페이지 락 또는 테이블락으로 레벨업(락 에스컬레이션) 되는 경우는 없다.
- 보통의 RDBMS와 다르게 InnoDB 스토리지 엔진에선 레코드 락뿐만 아니라 레코드와 레코드 사이의 간격을 잠그는 갭락이 존재한다.

#### 레코드 락
- 레코드 자체만을 잠그는 것을 레코드 락이라고 한다.
- 다른 DBMS의 레코드 락과 동일한 역할을 한다.
- **다른 DBMS의 레코드 락과 한가지 중요한 차이점은 InnoDB 스토리지 엔진은 레코드 자체가 아니라 인덱스의 레코드를 잠근다는 점이다.**
- InnoDB 테이블은 테이블 생성시 PK 인덱스를 명시적으로 지정하지 않아도 내부적으로 자동 생성된 클러스터 인덱스를 이용해서 잠금을 설정한다.

#### 갭락
- 다른 DBMS와 또 다른 차이가 갭락이다.
- 갭락은 레코드 자체가 아닌 레코드와 바로 인접한 레코드 사이의 간격만을 잠그는 것을 의미한다.
- 이러한 갭락은 레코드와 레코드 사이의 간격에 새로운 레코드가 생성되는 것을 제어 하는 역할을 한다.
- 조회 범위에 해당하는 인덱스 레코드의 가장 처음 인덱스 레코드와 직전 인덱스 레코드 사이, 그리고 마지막 인덱스 레코드와 그 이후 인덱스 레코드의 사이에 대해서 gap lock을 설정한다.
- 유니크 인덱스를 사용해서 특정 행을 검색할 때는 갭락이 사용 되지 않는다.
- **다만 멀티 칼럼 인덱스를 사용할 때 검색 조건이 일부만 사용하는 경우는 갭락을 사용한다.**
- 락은 그 자체 보다 넥스트 키 락의 일부로 자주 표현 / 사용 된다.

#### 넥스트 키락
- 레코드 락과 갭 락을 합쳐 놓은 형태의 잠금을 넥스트 키 락이라고 한다.
- InnoDB는 검색을 하거나 테이블 인덱스를 스캔할 때, 인덱스에 해당하는 레코드들에 S-LOCK이나 X-LOCK을 획득하는 방식으로 레코드 레벨의 잠금을 수행합니다.
- 따라서 레코드 레벨의 잠금은 인덱스 레코드 잠금을 의미합니다.
- **조회 범위에 해당하는 인덱스 레코드의 가장 처음 인덱스 레코드와 직전 인덱스 레코드 사이, 그리고 마지막 인덱스 레코드와 그 이후 인덱스 레코드의 사이에 대해서 gap lock을 설정한다.**

- 넥스트 키락은 격리 수준과 `innodb_locks_unsafe_for_binlog` 변수와 관계가 있다.
- `innodb_locks_unsafe_for_binlog`가 비활성화(=0)으로 되어 있으면 변경을 위해 검색하는 레코드에 넥스트 키 락 방식으로 잠금이 발생한다.
- 그러나 해당 변수는 5.6.3에서 Deprecated가 되었고 8.0에선 제거되었다.
- **격리 수준을 READ COMMITED으로 변경하면 넥스트 키락을 사용하지 않는다는 의미다.**
- repeable-read를 쓰면 넥스트 키락을 피할수 없다.

#### 자동증가 락
- MySQL에서는 자동 증가하는 숫자 값을 추출 하기 위해 AUTO_INCREMENT라는 칼럼 속성을 제공한다.
- 저장되는 각 레코드는 중복되지 않고 저장된 순서대로 증가하는 일련번호를 보장하기 위해 InnoDB 에서는 내부적으로 자동 증가 락인 테이블 수준의 잠금을 사용한다.

- insert, replace 쿼리와 같은 레코드를 저장하는 쿼리에만 필요하고, update나 delete 등에는 걸리지 않는다.
- 트랜잭션과 관계없이 auto increment 값을 가져오는 순간에만 락이 걸렸다가 해제된다.
- 테이블에 단 하나만 존재하기 때문에 락을 보유하는 순서의 일관성을 보장한다

- 명시적으로 락을 획득하고 해제하는 방법은 없다.
- 지금까지의 설명은 5.0 이하 버전에서만 사용되던 방식
- 5.1 이상부터는 `innodb_autoinc_lock_mode` 변수를 이용해 락의 작동 방식을 변경할 수 있다.

innodb_autoinc_lock_mode = 0 (**traditional)**
- 5.0과 동일한 잠금 방식으로 모든 INSERT된 문장은 자동 증가 락을 사용한다.
- 모든 insert 문장 실행시 테이블 레벨의 자동증가 락을 사용하고, insert 구문이 끝날 때까지 유지된다.

innodb_autoinc_lock_mode = 1 (**consecutive)**
- INSERT되는 레코드의 수를 정확히 예측할 수 있을 때는 가볍고 빠른 래치(뮤텍스)를 이용해 처리한다.
- 래치는 자동 증가 락과 달리 아주 짧은 시간 동안만 잠금을 걸고 필요한 자동 증가 값을 가져오면 즉시 잠금이 해제된다.
- 하지만 INSERT … SELECT와 같이 건수를 예측할 수 없을 때는 테이블 수준 잠금인 자동증가 락을 사용하고 명령문이 끝날 때 까지 유지 한다.
  - 할당된 모든 자동증가 값은 연속적인 값으로 된다.
  - 자동증가 값을 한번에 할당받기 때문이다.
- 다만 아래 쿼리와 같이 명시적으로 값을 제공하거나 NULL로 기재하는 내용이 혼재되어 있을 경우 삽입할 행 수 보다 더 많은 자동 증가 값을 할당하게 된다.

```sql
INSERT INTO TABLE VALUES (1,'A'), (NULL,'B'), (3,'C');
```

innodb_autoinc_lock_mode = 2 (**interleaved)**
- 절대 자동 증가 값을 걸지 않고 래치를 사용한다.
- 최소한 하나의 insert 문장으로 insert 되는 레코드라도 연속된 자동 증가 값을 보장하지 않는다.
  - 인터리빙 모드라고 한다.
  - 한 세션에서 멀티 insert문을 하더라도 다른 트랜잭션에서 실행되는 INSERT 문과의 AUTO_INCREMENT 값이 연속적이지는 않을 수 있다.
- INSERT … SELECT 와 같은 대량 INSERT가 실행되는 중에도 다른 커넥션에서 insert를 수행할 수 있어 **동시성이 높다.**
- 행수를 미리 알 수 있는 insert 문장은 자동 증가의 연속성이 보장된다
- 다만, 벌크 인서트는 공백이 있을 수 있다.
- STATEMENT 포맷의 바이너리 로그를 사용하는 복제에서는 레플리케이션 서버의 자동증가 값이 달라질 수 있기 때문에 주의해야 한다.
  - STATEMENT 포맷은 SQL 문장 자체를 로깅하는데, 프라이머리와 세컨더리의 실행순서가 일치하지 않을 수 있어 auto_increment 값의 일관성이 깨질 수 있다.
  - 이러한 문제를 피하기 위해 ROW 포맷 사용을 권장한다. ROW 포맷은 각 행에 실제로 발생한 변경 사항을 로그로 기록한다.
  - 즉 STATEMENT는 SQL 문장을 로깅하고, ROW 포맷은 데이터 자체를 로깅

```
💡 5.7 까지는 기본값이 1이였지만, 8.0부터는 기본값이 2다. 
왜냐하면 8.0 부터는 바이너리 로그 포맷이 STATEMENT가 아니라 ROW 포맷이 기본값이 되었기 때문이다.
8.0,에서 바이너리 로그 포맷을 STATEMENT로 사용한다면 2가아닌 1로 사용할 것을 권장한다.
```
- 모드가 1일 때는 AUTO_INCREMENT 값 할당이 연속적임을 보장하기 때문에 STATEMENT과 잘 호환
- 모드가 2일 때는 각 insert 명령이 독립적으로 자동 증가 값을 받는다. STATEMENT로 하면 위에서 말한것과 같이 프라이머리와 세컨더리의 AUTO_INCREMENT 값의 일관성이 깨질 수 있다.

- insert 쿼리가 실패(트랜잭션이 실패하거나 롤백되더라도)했더라도 한번 증가된 auto_increment값은 다시 줄어들지 않고 그대로 남는다
- 자동 증가값이 한번 증가하면 절대 줄어들지 않는 이유는 자동증가 잠금을 최소화하고 데이터 무결성을 보장하기 위함이다.
- 잠금 최소화
  - 감소를 허용한다면 다수의 트랜잭션에 동시에 자동증가 값을 요구할 때마다 해당 값에 대한 잠금과 잠금 해제 과정이 필요하게 된다. 이는 성능 저하를 초래할 수 있다.
  - 감소하지 않게 하여 잠금 관리를 단순화 시켜 성능을 향상
- 데이터 무결성 보장
  - 다른 레코드에 재할당 가능성을 막는다.

## MySQL의 격리 수준

### READ UNCOMMITTED 
- 각 트랜잭션의 변경 내용이 COMMIT이나 ROLLBACK 여부와 상관없이 다른 트랜잭션에서 보이게 되는 트랜잭션 격리 수준이다.
- 어떤 세션에서 진행 중인 트랜잭션이 처리가 완료 되지 않은 상태라도 다른 세션에서 해당 변경된 정보를 볼 수 있는 현상을 더티 리드라고 한다.
- READ UNCOMMITTED는 더티 리드가 허용되는 격리 수준이다.
- 더티 리드는 데이터가 보였다가 사라졌다 하는 현상을 초래한다.
- READ UNCOMMITTED는 데이터 정합성에 문제가 커서 dbms 표준에서 격리 수준으로 인정하지 않는다.
- MySQL 사용시 최소 READ COMMITTED 이상의 격리 수준을 권장한다.

### READ COMMITTED
- 오라클의 기본 격리 수준이다.
- READ UNCOMMITTED의 더티 리드 같은 현상은 발생하지 않는다.
- 어떤 트랜잭션에서 데이터를 변경하였을 때 COMMIT으로 트랜잭션이 완료되어야지만 다른 세션에서 변경된 데이터를 조회할 수 있다.
- 세션 A에서 데이터를 변경하고 COMMIT 하지 않았을 경우, 세션 B에서는 이전 데이터 값을 계속 조회하게 된다.
- 이 결과는 언두 레코르를 통해 이전 데이터를 가져온 것이다.
- READ COMMITTED에서 NON-REPEATABLE READ라는 부정합의 문제가 있다.
- NON-REPEATABLE READ는 하나의 트랜잭션에서 반복 읽기를 수행하면 다른 트랜잭션의 커밋 여부에 따라 조회 결과가 달라질 수 있다.
- 예를 들어 오늘 입금된 총 합을 계산하고 있는데, 다른 트랜잭션에서 계속해서 입금 내역을 커밋하는 상황이라고 하자. 
그러면 READ COMMITTED에서는 같은 트랜잭션일지라도 조회할 때마다 입급된 내역이 달라지므로 문제가 될 수 있다.
- READ COMMITTED 수준에서는 커밋된 데이터만 읽을 수 있기 때문에 트랜잭션 내에서 실행되는 SELECT와 트랜잭션 밖(다른 세션에서 진행중인 트랜잭션)에서 실행되는 SELECT의 차이가 별로 없다.
- 하지만 REPEATABLE READ 격리 수준에서는 기본적으로 SELECT 쿼리 문장도 트랜잭션 범위 내에서만 작동한다.
  - 즉, START TRANSACTION 명령으로 트랜잭션을 시작한 상태에서 온 종일 동일한 쿼리를 반복해서 실행하면, 계속 동일한 결과값만 보이게 된다.
    - 트랜잭션이 길어질 경우 다른 트랜잭션에서 먼저 commit을 했더라도 데이터를 볼 수 없다.( 트랜잭션 밖에서 실행되는 select와 차이가 있다.)
  - 이는 다른 세션에서 해당 데이터 값을 변경하고 COMMIT 하는 것과 무관하게 트랜잭션을 시작하고 조회한 시점의 데이터를 계속 동일하게 반복적으로 보여주게 되고 이런 의미로 REPEATABLE READ 라고 불린다.

### REPEATABLE READ
- MySQL INNODB 스토리지 엔진에서 기본적으로 사용되는 격리 수준
- READ COMMITTED에서 발생하는 NON-REPEATABLE READ 부정합이 발생하지 않는다.
- REPEATABLE READ와 READ COMMITTED 모두 MVCC를 이용해 COMMIT 되기 전 데이터를 보여주는 것은 동일하다.
- **하지만, REPEATABLE READ는 언두 영역에 백업된 레코드의 여러 버전 중에서 몇 번째 이전 버전까지 찾아 들어갈 수 있느냐의 차이가 있다.**

- 각각의 트랜잭션은 순차 증가하는 고유한 트랜잭션 번호가 존재하며, 언두 로그에는 어느 트랜잭션에 의해 백업되었는지 트랜잭션 번호를 함께 저장한다.
- 언두 영역의 백업된 데이터는 InnoDB 스토리지 엔진이 불필요하다고 판단되는 시점에 주기적으로 삭제한다.
- REPEATABLE READ 에선 MVCC를 보장하기 위해 실행 중인 트랜잭션 가운데 가장 오래 된 트랜잭션 번호 보다 앞선 언두 영역의 데이터는 삭제할 수 없다.
  - A 트랜잭션의 번호가 12
    - 12보다 작은 트랜잭션의 변경사항만 볼 수 있다.
  - B 트랜잭션의 번호가 10
    - 10보다 작은 트랜잭션의 변경사항만 볼 수 있다.
- **정확히는 특정 트랜잭션 번호 구간내에서 백업된 언두 데이터가 보존되어야 한다.**

### SERIALIZABLE
- 가장 단순한 격리 수준이면서 가장 엄격한 격리 수준이다.
- 그만큼 동시 처리 성능도 다른 트랜잭션 격리 수준보다 떨어진다.
- InnoDB에서 순수한 select는 아무런 레코드를 잠금하지 않고 실행한다.
  - Non-locking consistent read(잠금이 필요 없는 일관된 읽기)
- 하지만 SERIALIZABLE로 하게 되면 읽기 작업도 공유 잠금(읽기 잠금)을 획득해야만 하여, 동시에 다른 트랜잭션에서는 절대 접근할 수 없는 상황이 된다.

## 참고
- https://hoing.io/archives/4182
- https://hoing.io/archives/4713
- https://hoing.io/archives/4080
- https://hoing.io/archives/1289
- https://dev.mysql.com/doc/refman/8.0/en/mysqldump.html#option_mysqldump_single-transaction
- https://jeong-pro.tistory.com/241
- https://mangkyu.tistory.com/299
