# 04장 아키텍처

## MySQL의 구조

MySQL 데이터베이스 서버의 전체 구조는 다음 그림과 같다.

<img width="1062" alt="스크린샷 2024-04-24 오후 3 17 38" src="https://github.com/study-archivess/real-mysql/assets/101683784/dc30bc0f-1f91-4874-860b-349f0874eba1">

크게 MySQL 엔진, 스토리지 엔진으로 나눌 수 있다.

### MySQL 엔진
MySQL의 엔진은 클라이언트로부터의 접속 및 쿼리 요청을 처리하는 커넥션 핸들러, SQL 파서 및 전처리기, 그리고 쿼리 실행의 최적화를 위한 옵티마이저로 구성된다.
또한 MySQL은 표준 SQL을 지원하므로 다른 DBMS와의 호환성이 높다.

### 스토리지 엔진
MySQL 엔진이 실제 쿼리를 수행하는 책임을 가지고 있다면, 실제 데이터를 스토리지에 저장하고 읽어오는 부분은 스토리지 엔진이 전담한다.
특별한 점은 스토리지 엔진은 MySQL 엔진과 다르게 여러 개가 동시에 사용될 수 있다는 점이다.
이러한 구조를 `플러그형 스토리지 엔진 아키텍처` 라고 하고, 이는 `핸들러 API`라는 인터페이스를 통해 가능하다.

### 핸들러 API
핸들러 API는 데이터베이스 엔진과 상호 작용하는 내부 인터페이스로, 스토리지 엔진이 MySQL 서버와 통신하는 방식을 정의한다. 
MySQL이 각 스토리지 엔진에 보내는 요청을 `핸들러 요청` 이라고 하고, 다양한 스토리지 엔진이 MySQL의 기본 프레임워크 안에서 동작할 수 있게 돕는 역할을 한다. 
핸들러 API를 통해 개발자들은 MySQL에 자신의 스토리지 엔진을 통합할 수 있고, 이를 통해 데이터 관리 및 처리 방식을 맞춤화할 수 있게 된다.
이러한 부분이 Spring Framework의 `Plug and Play` 아키텍처와 많이 닮아있었다. 개발자에게 다양한 구성 요소를 쉽게 추가하고 변경할 수 있는 유연성을 제공하고 여러 서비스에서 널리 사랑받는 이유일지도 모르겠다.

## MySQL의 스레딩

MySQL 서버는 프로세스 기반이 아닌 스레드 기반으로 작동한다.

### 왜 스레드 기반일까?

MySQL 서버가 스레드 기반으로 설계된 주된 이유는 성능과 자원 효율성 때문이다.
프로세스 기반의 구조와 스레드 기반의 구조를 간단하게 비교해보자

프로세스 기반 시스템에서는 각 클라이언트의 요청을 개별 프로세스가 처리한다.
각 프로세스는 독립적인 메모리 공간을 가지며, 프로세스 간의 자원 공유는 IPC를 통해서 가능하다. 예시로는 크롬 브라우저에서 여러 탭을 사용했을 때를 생각해보면 좋다.
이러한 구조는 각 프로세스가 독립적으로 실행되므로 안정성이 높은 반면, 자원 사용의 효율성이 낮고, 프로세스간 커뮤니케이션 비용이 높아질 수 있다.

반면에, 스레드 기반 시스템에서는 하나의 프로세스 내에서 다수의 스레드가 동작하며, 이 스레드들은 프로세스의 메모리와 자원을 공유하는 형태로 존재한다.
스레드는 경량 프로세스로 간주되며, 생성과 관리가 프로세스에 비해 상대적으로 간단하고 비용이 적게 든다.
스레드 간의 자원 공유는 자연스럽게 이루어지므로, 커뮤니케이션 비용이 낮고 자원 사용이 효율적인 구조라고 할 수 있다.

MySQL과 같은 데이터베이스 서버는 다수의 동시 연결과 요청을 효율적으로 처리해야한다. 따라서, 자원 사용을 최적화하고, 생성이나 컨텍스트 스위칭에 있어서 스레드 기반의 구조를 띄는 것이
성능적인 이점이 있는 셈이다.

### 포그라운드 스레드(클라이언트 스레드)

MySQL은 주로 두 가지 유형의 스레드를 사용한다. 그 중 포그라운드 스레드라는 형식의 스레드가 있다.
포그라운드 스레드는 각 클라이언트 연결에 대응하여 생성된다. 즉 클라이언트 수 만큼 서버에 존재하며 각 클라이언트의 요청을 처리하는 책임을 담당하게 된다.
클라이언트가 연결을 종료하게 되면 기본적으로 스레드는 삭제된다. 
하지만 설정에 따라 일정 개수의 스레드는 스레드 캐시 영역에 존재하게 된다. (마치 WAS의 스레드 풀을 생각하면 쉽다)
이때 일정 개수는 삭제되는 것이 아니라 캐시 영역에 보관함으로써 조금 더 빠르게 반응할 수 있도록 한다. (이는 시스템 변수로 관리한다고 한다.)

### 백그라운드 스레드

포그라운드 스레드가 클라이언트와의 상호작용을 담당했다면, 백그라운드 스레드는 말 그대로 뒷단에서의 작업을 담당한다.
이 스레드들은 보이지 않는 곳에서 실행되며, 데이터베이스의 성능과 안정성을 유지하기 위해 중요한 역할을 수행한다. 
예를 들어, 디스크에 데이터를 주기적으로 쓰기 작업을 실행한다던가, 로그를 디스크에 기록한다던가, 혹은 레플리케이션 구성 시 Master DB의 변동사항을 Slave DB에 반영하는 등의 역할이 있다.

이러한 백그라운드 스레드는 사용자의 직접적인 요청에 응답하지 않고, 시스템의 내부 프로세스를 지원하여 전체적인 데이터베이스 성능을 최적화하는데에 의의가 있다.

## MySQL의 메모리 관리

MySQL의 메모리 구조는 크게 글로벌 메모리 영역과 세션 메모리 영역으로 나눌 수 있는데, 대략적으로 그림으로 나타내면 이렇다.

<img width="819" alt="스크린샷 2024-04-24 오후 5 51 29" src="https://github.com/study-archivess/real-mysql/assets/101683784/1a468a09-f690-46dc-9602-cba3158c2040">

### 글로벌 메모리 영역

글로벌 메모리 영역은 서버 전체에서 공유되는 자원을 관리한다. 이는 모든 스레드가 접근할 수 있는 메모리 영역으로, 데이터베이스의 핵심 성능을 결정하는 구성 요소들이 존재한다.
그 안의 세부적인 역할을 살펴보자.

- 테이블 캐시
  - 테이블의 구조를 캐싱하여, 서버가 테이블에 대한 정보를 빠르게 접근할 수 있게 한다.
- InnoDB 버퍼 풀
  - 가장 중요한 데이터 캐시 구성 요소로, InnoDB 테이블의 데이터와 인덱스를 메모리에 저장한다.
  - 사용자가 데이터를 요청하면 InnoDB 버퍼 풀에서 먼저 데이터를 찾고, 없을 경우 디스크에서 읽어 버퍼 풀에 저장 후 반환하는 식으로 동작한다.
- MyISAM 키 캐시
  - MyISAM 테이블의 인덱스를 메모리에 캐싱한다.
  - 인덱스 검색 시, 디스크 I/O 없이 빠르게 인덱스를 접근할 수 있어 검색 속도가 향상된다.
- InnoDB 어댑티브 해시 인덱스
  - 자주 접근하는 데이터에 대해 해시 인덱스를 생성한다.
  - B-tree 검색 보다 빠른 검색을 제공해서 성능 향상을 기대할 수 있다.
- 바이너리 로그 버퍼
  - 데이터 변경 정보를 메모리에 임시로 저장하고, 주기적으로 디스크에 있는 바이너리 로그 파일로 저장한다.
  - 트랜잭션이 커밋되면 해당 정보가 로그 버퍼에 먼저 쓰이고, 이후 로그 파일로 저장된다.
- InnoDB 리두 로그 버퍼
  - 데이터베이스가 충돌 후 복구할 수 있도록 변경 사항을 기록하는 버퍼
  - 데이터가 변경될 때마다 리두 로그 버퍼에 먼저 기록되고, 나중에 디스크에 있는 로그 파일로 플러시됨.

### 로컬 메모리 영역

로컬 메모리 영역은 각 스레드가 독립적으로 사용하는 메모리 공간이다. 이 영역은 스레드의 작업을 지원하기 위해 사용되며, 각 스레드의 요구에 따라 동적으로 할당된다.

- 정렬 버퍼
  - ORDER BY나 GROUP BY 쿼리에서 사용되는 데이터를 임시로 저장하는 버퍼
  - 사용자가 데이터를 특정 순서로 조회 요청 시, 정렬 버퍼를 사용하여 데이터를 정렬한 후 결과를 반환
- 조인 버퍼
  - 조인 작업에서 사용되는 테이블의 행을 저장하는 버퍼
  - 테이블을 조인할 때, 조인 버퍼를 사용하여 관련 데이터를 메모리에 임시 저장하고 조인 작업을 수행
- 바이너리 로그 캐시
  - 각 스레드가 자신의 바이너리 로그 변경 사항을 저장하는 캐시
  - 트랜잭션 동안 변경된 내용이 바이너리 로그 캐시에 저장되고, 트랜잭션이 커밋되면 글로벌 바이너리 로그 파일로 플러시됨.
- 네트워크 버퍼
  - 클라이언트와의 네트워크 데이터 교환을 위해 사용되는 버퍼
  - 이터를 클라이언트에게 전송할 때, 네트워크 버퍼를 통해 데이터를 일시적으로 저장하고 순차적으로 전송
- 리드 버퍼
  - 디스크에서 데이터를 읽을 때 사용하는 버퍼
  - 순차적인 데이터 읽기를 최적화하는 역할

## 플러그인 스토리지 엔진 모델

MySQL의 플러그인 스토리지 엔진 모델은 데이터베이스 시스템에서 데이터 저장 및 검색 방식을 결정하는 핵심 구성요소이다. 
위에서 간단게 언급한것 처럼 서버의 유연성을 크게 확장시키고 개발자가 자유롭게 시스템을 설정할 수 있도록 돕는 구조이다.

MySQL은 여러 스토리지 엔진을 지원하며, 이 중 일부는 기본적으로 내장되어 있고, 다른 일부는 필요에 따라 추가하거나 제거할 수 있는 플러그인 형태로 제공된다.
스토리지 엔진은 데이터의 저장 및 검색, 트랜잭션 처리, 캐싱, 인덱싱 등 다양한 데이터베이스 관리 작업을 수행할 수 있다.

### 핸들러 API의 역할과 동작

핸들러는 CRUD (생성, 읽기, 업데이트, 삭제) 작업, 트랜잭션 관리, 인덱스 처리 등 다양한 데이터베이스 연산을 수행한다.
```
데이터 조작:
  ha_write_row(): 새로운 행을 삽입합니다.
  ha_update_row(): 기존 행을 수정합니다.
  ha_delete_row(): 행을 삭제합니다.

데이터 검색:
  ha_read_row(): 조건에 맞는 행을 읽습니다.
  ha_index_read(): 인덱스를 사용하여 특정 행을 찾고 읽습니다.

트랜잭션 관리:
  ha_commit_trans(): 트랜잭션을 커밋합니다.
  ha_rollback_trans(): 트랜잭션을 롤백합니다.

테이블 및 인덱스 관리:
  ha_create_table(): 새로운 테이블을 생성합니다.
  ha_drop_table(): 테이블을 삭제합니다.
  ha_create_index(), ha_drop_index(): 인덱스를 생성하고 삭제합니다.
```
## MySQL의 컴포넌트

아까 엔진 부분에서 살펴봤던 엔진을 구성하는 여러 컴포넌트들의 동작을 정리해보자.

### 커넥션 핸들러(Connection Handler)
기능: 클라이언트로부터의 접속 요청을 관리하고, 사용자 인증을 처리한다. 클라이언트와의 네트워크 연결을 설정하고 유지하는 역할을 맡는다
동작 예시: 사용자가 MySQL 서버에 접속 요청을 할 때, 커넥션 핸들러는 사용자의 아이디와 패스워드를 검증하고, 성공적인 인증 후 세션을 생성한다.

### SQL 인터페이스
기능: 사용자의 SQL 쿼리를 입력받아 다음 단계로 전달한다. 이는 사용자와 시스템 간의 인터페이스 역할을 한다.
동작 예시: 사용자가 쿼리 `SELECT * FROM users;`를 입력하면, SQL 인터페이스는 이 쿼리를 받아 파서로 전달한다.

### SQL 파서(SQL Parser)
기능: SQL 쿼리를 구문 분석하여 그 구조를 이해하고, 쿼리가 문법적으로 올바른지 검증한다. 이 과정에서 파싱 트리라는 형태로 데이터가 파싱된다.
동작 예시: `SELECT * FROM users` 쿼리가 주어지면, 파서는 이를 분석하여 'SELECT' 명령과 'FROM users'라는 테이블 지정 부분을 식별한다.

### SQL 옵티마이저(SQL Optimizer)
기능: 쿼리 실행 계획을 생성하고, 여러 가능한 실행 경로 중에서 가장 효율적인 방법을 선택한다. 이는 쿼리의 성능을 최적화하는 데 큰 역할을 한다.
동작 예시: `SELECT * FROM users WHERE age > 30` 쿼리에 대해 옵티마이저는 인덱스 사용 여부, 조인 방법 등을 고려하여 최적의 실행 계획을 결정합니다.

### 캐시 & 버퍼(Cache & Buffer)
기능: 자주 접근하는 데이터나 결과를 메모리에 저장하여, 동일한 요청에 대해 빠르게 응답할 수 있도록 한다. 버퍼는 디스크 I/O를 줄이기 위해 사용되며, 캐시는 쿼리 결과를 임시로 저장한다.
동작 예시: 사용자가 `SELECT * FROM users` 쿼리를 반복적으로 실행할 때, 첫 실행 결과는 캐시에 저장되어, 후속 쿼리 요청 시 디스크 접근 없이 빠르게 결과를 반환할 수 있게 된다.










