### 1) 풀 테이블 스캔과 플 인덱스 스캔

일반적으로 테이블의 전체 크기는 인덱스보다 훨씬 크기 때문에 </br>
테이블을 처음부터 끝까지 읽는 작업은 많은 디스크 읽기가 필요하다.

InnoDB 스토리지 엔진은 특정 테이블의 연속된 데이터 페이지가 읽히면 </br>
백그라운드 스레드에 의해 Read ahead 작업이 자동으로 시작된다. </br>
Read ahead 는 필요한 데이터를 미리 예측해 디스크에서 읽어 버퍼 풀에 가져다 두는 것이다.

풀 테이블 스캔이 실행되면 처음 몇 페이지는 포그라운드 스레드가 실행하다 백그라운드 스레드로 넘긴다.</br>
이때 한 번에 최대 64개의 데이터 페이지까지 읽어서 버퍼 풀에 저장한다.</br>
포그라운드 스레드는 미리 버퍼 풀에 준비된 데이터를 사용하면 되므로 쿼리가 상당히 빨리 처리된다.</br>
`innodb_read_ahead_threshold` 시스템 변수를 이용해 Read ahead 임계값을 설정할 수 있다.</br>
Read ahead 는 풀 인덱스 스캔에서도 동일하게 사용된다.

```sql
SELECT COUNT(*) FROM employees;
```

위의 쿼리 예시는 조건 없는 조회 쿼리 이므로 풀 테이블 스캔을 할것으로 예상되나, 실제 풀 인덱스 스캔을 한다.</br>
이유는 단순 레코드 건수만 필요한 쿼리이므로 용량이 작은 인덱스 스캔을 선택해 디스크 읽기 횟수를 줄이기 때문이다.

### 2) 병렬 처리

MySQL 8.0 부터 쿼리 병렬처리(하나의 쿼리를 여러 스레드가 작업을 나누어 동시에 처리)가 가능하다. </br>
`innodb_parallel_read_threads` 시스템 변수를 이용해 하나의 쿼리를 최대 몇 개의 스레드를 이용해서 처리할지 설정한다.
```sql
SET SESSION innodb_parallel_read_threads=4;
```
8.0 버전에서는 아무런 WHERE 조건 없이 단순 테이블 전체 건수 가져오는 쿼리만 병렬 처리할 수 있다. </br>
병렬 처리용 스레드 개수를 늘리면 수행 시간이 줄어들지만, 서버에 장착된 CPU의 코어 개수를 넘어서는 경우에는 오히려 성능이 떨어질 수도 있다.

### 3) ORDER BY 처리 (Using filesort)

레코드 1~2건을 가져오는 쿼리를 제외하면 대부분의 SELECT 쿼리에서 정렬은 필수적으로 사용된다.


|     정렬을 처리하는</br> 두가지 방식     | 장점                                                                                                             | 단점                                                      |
|:----------------------------:|----------------------------------------------------------------------------------------------------------------|---------------------------------------------------------|
|             인덱스              | INSERT, UPDATE, DELETE 쿼리가 실행될 때 이미 인 덱스가 정렬돼 있어서 순서대로 읽기만 하면 되므로 매우 빠르다.                                      |  INSERT, UPDATE, DELETE 작업 시 부가적인 인덱스 추가/삭제 작업이 필요하므로 느리다.</br> 인덱스 때문에 디스크 공간이 더 많이 필요하다.</br> 인덱스의 개수가 늘어날수록 InnoDB의 버퍼 풀을 인덱스 이용 위한 메모리가 많이 필요하다.   |                           |
|           Filesort           | 인덱스를 생성하지 않아도되므로 인덱스를 이용할 때 Filesort 이용의 단점이 장점으로 바뀐다.</br> 정렬해야 할 레코드가 많지 않으면 메모리에서 Filesort 가 처리되므로 충분히 빠르다. |  정렬 작업이 쿼리 실행 시 처리되므로 레코드 대상 건수가 많아질수록 쿼리의 응답 속도가 느리다.                          |

**인덱스 이용이 힘든 경우**
- 정렬 기준이 너무 많아서 요건별로 모두 인덱스를 생성하는 것이 불가능한 경우
- GROUP BY의 결과 또는 DISTINCT 같은 처리의 결과를 정렬해야 하는 경우
- UNION 의 결과와 같이 임시 테이블의 결과를 다시 정렬해야 하는 경우
- 랜덤하게 결과 레코드를 가져와야 하는 경우

인덱스를 이용하지 않고 별도의 정렬 처리를 수행했는지는 실행 계획의 Extra 칼럼에 Using filesort 메시지가 표시되는지 여부로 판단한다.

//로컬메모리 영역 설명
https://blog.ex-em.com/1682

#### 1. 소트 버퍼 Sort buffer

- 소트 버퍼는 정렬을 수행하기 위해 별도의 메모리 공간을 할당받아서 사용하는 메모리 공간
- 쿼리의 실행이 완료되면 즉시 시스템으로 반납된다.
- 정렬해야 할 레코드의 건수가 소트 버퍼로 할당된 공간보다 크다면 정렬해야 할 레코드를 여러 조각으로 나눠서 처리하는데</br> 이 과정에서 임시 저장을 위해 디스크를 사용한다.
- 기본 sort buffer size 262144, 262KB.</br>
책에서 테스트 시 256KB-8MB 사이가 최적의 성능을 보였고, 문서에서는 리눅스 환경 에서 256KB-2MB 사이를 권장한다. 설정된 사이즈를 넘길경우 memory 문제가 생길 수 있다.</br>
(https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_sort_buffer_size)
- 멀티 머지: 메모리의 소트 버퍼에서 정렬 하고, 그 결과를 임시로 디스크에 기록하고 다음 레코드를 가져와 이 작업을 병합, 반복한다. 
- 수행된 멀티 머지 횟수는 sort_merge_passes 변수에 누적 집계된다.
- 소트 버퍼는 세션 메모리 영역에 해당하므로 클라이언트가 공유하지 않는다.
- 커넥션이 많고, 정렬 작업이 많을수록 소트 버퍼로 소비되는 메모리 공간이 커진다.

#### 2. 정렬 알고리즘

레코드를 정렬할 때 레코드 전체를 소트 버퍼에 담을지 또는 정렬 기준 칼럼만 소트 버퍼에 담을지에 따라 
싱글 패스(Single-pass)/투 패스(Two-pass) 2가지 정렬 모드로 나눈다.

- MySQL 서버의 3가지 정렬 방식
  - <sort_key, rowid>: 정렬 키와 레코드의 로우 아이디(Row ID)만 가져와서 정렬하는 방식
  - <sort_key, additional_fields>: 정렬 키와 레코드 전체를 가져와서 정렬하는 방식으로, 레코드의 칼럼들은 고정 사이즈로 메모리 저장
  - <sort_key, packed_additional_fields>: 정렬 키와 레코드 전체를 가져와서 정렬하는 방식으로, 레코드의 칼럼 들은 가변 사이즈로 메모리 저장


- 싱글 패스 Single-pass
  - <sort_key, additional_fields>, <sort_key, packed_additional_fields>
  - 소트 버퍼에 정렬 기준 칼럼을 포함해 SELECT 대상이 되는 칼럼 전부를 담아서 정렬을 수행하는 정렬 방식이다 </br>
    처음 employees 테이블을 읽을 때 정렬에 필요하지 않은 last_name 칼럼까 지 전부 읽어서 소트 버퍼에 담고 정렬을 수행한다.</br>
    정렬이 완료되면 정렬 버퍼의 내용을 그대 로 클라이언트로 넘겨준다.
    투패스 방식보다 더 많은 소트 버퍼 공간이 필요하다.


- 투 패스 Two-pass
  - <sort_key, rowid>
  - 정렬 대상 칼럼과 프라이머리 키 값만 소트 버퍼에 담아서 정렬을 수행하고, 정렬된 순서대로 다시 프라이머리 키로 테이블을 읽어서 SELECT 할 칼럼을 가져오는 방식이다.
  - 처음 `employees` 테이블을 읽을 때는 정렬에 필요한 `first_name` 칼럼과 프라이머리 키인 `emp_no` 만 읽어서 정렬을 수행한다.
  - 레코드 크기가 `max_length_for_sort_data` 설정 값보다 클때, BLOB, TEXT 타입 컬럼을 SELECT 할때에는 투패스 정렬 방식을 사용한다.

#### 3. 정렬 처리 방법
- 쿼리에 ORDER BY가 사용되면 3가지 처리 방법 중 하나로 정렬되고 뒤로갈수록 처리 속도가 떨어진다.
  - a. 인덱스를 사용한 정렬
  - b. 조인에서 드라이밍 테이블만 정렬 (Using filesort 표시)
  - c. 조인에서 조인 결과를 임시 테이블로 저장 후 정렬 (Using temporary; Using filesort 표시)
- 먼저 옵티마이저는 정렬 처리를 위해 인덱스를 이용할 수 있을지 검토한다.
- 인덱스를 이용할 수 있다면 별도의 Filesort 과정 없이 인덱스를 순서대로 읽어서 결과를 반환한다.
- 인덱스를 사용할 수 없다면 WHERE 조건에 일치하는 레코드를 검색해 정렬 버퍼에 저장하면서 정렬을 처리(Filesort)한다.

**a. 인덱스를 사용한 정렬**</br>
인덱스를 이용한 정렬을 위해서는 반드시 ORDER BY에 명시된 칼럼이 제일 먼저 읽는 테이블(드라이빙)에 속하고, ORDER BY의 순서대로 생성된 인덱스가 있어야 한다.</br>
WHERE 절에 첫 번째로 읽는 테이블의 칼럼에 대한 조건이 있다면, 그 조건과 ORDER BY는 같은 인덱스를 사용할 수 있어야 한다.</br>
인덱스를 이용해 정렬이 처리되는 경우에는 실제 인덱스의 값이 정렬돼 있기 때문에 인덱스의 순서대로 읽기만 하면 된다.</br>
별도의 정렬을 위한 추가 작업을 수행하지 않는다


**b. 조인에서 드라이빙 테이블만 정렬**</br>
조인이 수행되면 결과 레코드의 건수와 크기도 늘어난다.</br>
차선책으로 조인을 실행하기 전에 첫 번째 테이블의 레코드를 먼저 정렬한 다음 조인을 실행할 수 있다.</br>
이 방법으로 정렬이 처리되려면 조인에서 첫 번째로 읽히는 테이블(드라이빙 테이블)의 칼럼만으로 ORDER BY 절을 작성해야 한다.


```sql
SELECT *
FROM employees e, salaries s 
WHERE s.emp_no=e.emp_no
    AND e.emp_no BETWEEN 100002 AND 100010
ORDER BY e.last_name;
```

WHERE 절이 다음 2가지 조건을 갖추고 있다면 드라이빙 테이블로 선택한다.
- WHERE 절의 검색 조건(“emp_no BETWEEN 100001 AND 100010”)은 employees 테이블의 프라이머리 키를 이용해 검색하면 작업량을 줄일 수 있다.
- 드리븐 테이블(salaries)의 조인 칼럼인 emp_no 칼럼에 인덱스가 있다.

옵티마이저는 드라이빙 테이블만 검색해서 정렬을 수행하고, 그 결과와 salaries 테이블은 조인한 것이다.

**9.5

i. 인덱스를 이용해 “emp_no BETWEEN 100001 AND 100010” 조건을 만족하는 9건 검색</br>
ii. 검색 결과를 last_name 칼럼으로 정렬을 수행(Filesort)</br>
iii. 정렬된 결과를 순서대로 읽으면서 salaries 테이블과 조인을 수행해 86건의 결과를 가져옴.


**c. 조인에서 조인 결과를 임시 테이블로 저장 후 정렬**</br>
2개 이상의 테이블을 조인해서 그 결과를 정렬해야 한다면 임시 테이블이 필요할 수도 있다.</br>
이 방법은 정렬의 3가지 방법 가운데 정렬해야 할 레코드 건수가 가장 많기 때문에 가장 느린 정렬 방법이다.

```sql
SELECT *
FROM employees e, salaries s 
WHERE s.emp_no=e.emp_no
    AND e.emp_no BETWEEN 100002 AND 100010
ORDER BY s.salary;
```

위 쿼리의 실행 계획을 살펴보면 Extra 칼럼에 `Using temporary; Using filesort` 가 표시된다.
드리븐 테이블 컬럼 salary 로 정렬하므로, 조인 결과를 임시 테이블에 저장하고 그 결과를 다시 정렬처리하게 된다.

**9.6

**d. 정렬 처리 성능 비교**
LIMIT 은 테이블이나 처리 결과의 일부만 가져오기 때문에 MySQL 서버가 처리해야 할 작업량이 줄어드는 역할을 한다.</br>
그런데 우선 조건을 만족하는 레코드를 모두 가져와 정렬을 수행하거나 그루핑 작업을 실행해야 LIMIT 건수를 제한할 수 있다.

**쿼리가 처리되는 2가지 방식**

1. 스트리밍 방식</br>
빠른 응답시간을 위해 사용하는 방식이다.</br>
처리할 데이터의 양과 관계없이 조건에 일치하는 레코드가 검색될때마다 바로 클라이언트에 전송하는 방식이다.</br>
풀 테이블 스캔의 결과가 아무 버퍼링 처리나 필터링 과정없이 클라이언트로 스트리밍 된다.</br>
쿼리를 요청하고 곧바로 첫번째 레코드를 전달받는다.


2. 버퍼링 방식</br>
ORDER BY 나 GROUP BY 처리는 쿼리 결과 스트리밍이 불가능하다.</br>
레코드 검색 후 정렬 또는 그루핑작업 하는 동안 클라이언트는 대기해야 한다. 이 방식을 버퍼링 방식 이라고 한다.


> MySQL 서버가 스트리밍 방식으로 처리해서 반환해도 
> 클라이언트의 JDBC 라이브러리를 사용한다면 서버로부터 받는 레코드를 일단 내부 버퍼에 담아두고 마지막 결과를 받으면 애플리케이션에 반환한다.
> 이는 불필요한 네트워크 요청을 최소화 하여 전체 처리량을 높이기 위해서이다.
> 하지만 대량의 데이터를 가져와야 항떄 전송방식을 스트리밍 방식으로 변경할 수 있다.

정렬 처리 방식 중 인덱스를 사용한 정렬 방식만 스트리밍 처리 방식이고, 나머지는 버퍼링되서 정렬된다.</br>
어떤 테이블이 먼저 드라이빙 되어 조인되는지도 중요하지만 어떤 정렬 방식으러 처리되는지가 큰 성능 차이가 나므로,</br>
최소 드라이빙 테이블 정렬로 구성하는 것이 좋은 튜닝 방법이다.


> 인덱스를 사용하지 못하는 쿼리는 LIMIT로 조회하더라도 성능이 크게 좋아지지 않는다.




