09_옵티마이저와 힌트
===

서버로 요청된 쿼리의 결과가 동일해도 내부적으로 처리하는 방법은 다양하다.

다양한 방법 중 최소의 비용이 드는 최적화된 방법을 찾아야 한다. 

MySQL의 옵티마이저는 쿼리를 최적으로 실행하기 위해 테이블 데이터 분포 통계 정보를 참조하며,
기본 데이터를 비교해 실행 계획을 수립하는 것을 담당한다.

`EXPLANE` 명령으로 쿼리의 실행 계획을 확인할 수 있다.

MySQL 서버가 데이터를 가공하는 기본 절차와 최적화에 대해 살펴보겠다.

## 개요

### 1. 쿼리 실행 절차

```
3단계 실행 절차

1. SQL 파싱 단계
- 사용자로부터 요청된 SQL 문장을 쪼개 서버가 이해할 수 있는 수준으로 분리. (파스 트리)
- SQL 파서 모듈로 처리하며, SQL 파스 트리가 만들어진다.

2. 최적화 및 실행 계획 수립 단계
- 파싱 정보(파스 트리)를 참조하면서 어떤 테이블, 인덱스를 이용할지 선택.
-  다음의 내용을 옵티마이저에서 처리
  > 불필요한 조건 제거 및 복잡한 연산의 단순화
  > 여러 테이블의 조인이 있는 경우 어떤 순서로 테이블을 읽을지 결정
  > 각 테이블에 사용된 조건과 인덱스 통계 정보를 이용해 사용할 인덱스를 결정
  > 가져온 레코드들을 임시 테이블에 넣고 다시 한번 가공해야 하는지 결정

3. 실행 계획 수행 단계
- 두번째 단계에서 결정된 실행 계획을 이용해 스토리지 엔진으로부터 데이터를 가져옴.
- 읽어온 레코드를 조인, 정렬 하는 작업 수행.
```

### 2. 옵티마이저의 종류
옵티마이저는 데이터베이스 서버에서 두뇌와 같은 역할을 담당하는데 
크게 두가지 종류로 나눌 수 있다.

- 규칙 기반 최적화 (Rule-based optimizer, RBO) 
  - 초기 버전의 오라클에서 사용했던 방법.
  - 대상 테이블 선택도 등을 고려하지 않고 우선순위에 따라 실행 계획을 수립하는 방식이다.
  - 사용자 데이터 분포도 및 통계를 고려하지 않기에, 같은 쿼리에 대해 항상 같은 실행 방법을 수행한다.

- 비용 기반 최적화 (Cost-based optimizer, CBO)
    - 현재 대부분의 DBMS가 선택하고 있는 방법.
    - 쿼리 처리를 위한 여러 방법을 만들고, 각 단위 작업 비용, 부하 정보와 대상 테이블의
      예측 통계를 이용해 실행 계획 별 비용을 산출한다.
    - 산출된 실행 계획 비용 중 최소 비용을 선택해 쿼리를 실행 한다.



-------------------
# 기본 데이터 처리

## 1. 풀 테이블 스캔과 풀 인덱스 스캔

**풀 테이블 스캔**
인덱스를 사용하지 않고 테이블의 데이터를 처음부터 끝까지 읽어서 요청된 작업을 처리.</br>
- 옵티마이저가 풀 테이블 스캔을 하는 경우
  - 테이블의 레코드 건수가 너무 작아서 인덱스를 통해 읽는 것보다 풀 테이블 스캔을 하는 편이 더 빠른 경우
  - WHERE 절이나 ON 절에 인덱스를 이용할 수 있는 적절한 조건이 없는 경우
  - 인덱스 레인지 스캔을 사용할 수 있는 쿼리라고 하더라도 옵티마이저가 판단한 조건 일치 레코드 건수가 너무 많은 경우

일반적으로 테이블의 전체 크기는 인덱스보다 훨씬 크기 때문에 </br>
테이블을 처음부터 끝까지 읽는 작업은 많은 디스크 읽기가 필요하다.

InnoDB 스토리지 엔진은 특정 테이블의 연속된 데이터 페이지가 읽히면 </br>
백그라운드 스레드에 의해 Read ahead 작업이 자동으로 시작된다. </br>
Read ahead 는 필요한 데이터를 미리 예측해 디스크에서 읽어 버퍼 풀에 가져다 두는 것이다.

풀 테이블 스캔이 실행되면 처음 몇 페이지는 포그라운드 스레드가 실행하다 백그라운드 스레드로 넘긴다.</br>
이때 한 번에 최대 64개의 데이터 페이지까지 읽어서 버퍼 풀에 저장한다.</br>
포그라운드 스레드는 미리 버퍼 풀에 준비된 데이터를 사용하면 되므로 쿼리가 상당히 빨리 처리된다.</br>
`innodb_read_ahead_threshold` 시스템 변수를 이용해 Read ahead 임계값을 설정할 수 있다.</br>
Read ahead 는 풀 인덱스 스캔에서도 동일하게 사용된다.

```sql
SELECT COUNT(*) FROM employees;
```

위의 쿼리 예시는 조건 없는 조회 쿼리 이므로 풀 테이블 스캔을 할것으로 예상되나, 실제 풀 인덱스 스캔을 한다.</br>
이유는 단순 레코드 건수만 필요한 쿼리이므로 용량이 작은 인덱스 스캔을 선택해 디스크 읽기 횟수를 줄이기 때문이다.


## 2. 병렬 처리

MySQL 8.0 부터 쿼리 병렬처리(하나의 쿼리를 여러 스레드가 작업을 나누어 동시에 처리)가 가능하다. </br>
`innodb_parallel_read_threads` 시스템 변수를 이용해 하나의 쿼리를 최대 몇 개의 스레드를 이용해서 처리할지 설정한다.
```sql
SET SESSION innodb_parallel_read_threads=4;
```
8.0 버전에서는 아무런 WHERE 조건 없이 단순 테이블 전체 건수 가져오는 쿼리만 병렬 처리할 수 있다. </br>
병렬 처리용 스레드 개수를 늘리면 수행 시간이 줄어들지만, 서버에 장착된 CPU의 코어 개수를 넘어서는 경우에는 오히려 성능이 떨어질 수도 있다.


## 3. ORDER BY 처리 (Using filesort)

레코드 1~2건을 가져오는 쿼리를 제외하면 대부분의 SELECT 쿼리에서 정렬은 필수적으로 사용된다.


|     정렬을 처리하는</br> 두가지 방식     | 장점                                                                                                             | 단점                                                      |
|:----------------------------:|----------------------------------------------------------------------------------------------------------------|---------------------------------------------------------|
|             인덱스              | INSERT, UPDATE, DELETE 쿼리가 실행될 때 이미 인 덱스가 정렬돼 있어서 순서대로 읽기만 하면 되므로 매우 빠르다.                                      |  INSERT, UPDATE, DELETE 작업 시 부가적인 인덱스 추가/삭제 작업이 필요하므로 느리다.</br> 인덱스 때문에 디스크 공간이 더 많이 필요하다.</br> 인덱스의 개수가 늘어날수록 InnoDB의 버퍼 풀을 인덱스 이용 위한 메모리가 많이 필요하다.   |                           |
|           Filesort           | 인덱스를 생성하지 않아도되므로 인덱스를 이용할 때 Filesort 이용의 단점이 장점으로 바뀐다.</br> 정렬해야 할 레코드가 많지 않으면 메모리에서 Filesort 가 처리되므로 충분히 빠르다. |  정렬 작업이 쿼리 실행 시 처리되므로 레코드 대상 건수가 많아질수록 쿼리의 응답 속도가 느리다.                          |

**인덱스 이용이 힘든 경우**
- 정렬 기준이 너무 많아서 요건별로 모두 인덱스를 생성하는 것이 불가능한 경우
- GROUP BY의 결과 또는 DISTINCT 같은 처리의 결과를 정렬해야 하는 경우
- UNION 의 결과와 같이 임시 테이블의 결과를 다시 정렬해야 하는 경우
- 랜덤하게 결과 레코드를 가져와야 하는 경우

인덱스를 이용하지 않고 별도의 정렬 처리를 수행했는지는 실행 계획의 Extra 칼럼에 Using filesort 메시지가 표시되는지 여부로 판단한다.


메모리 영역 설명
https://blog.ex-em.com/1682
![9.1.png](hyunhwaoh-images%2F9.1.png)


### 1) 소트 버퍼 Sort buffer

- 소트 버퍼는 정렬을 수행하기 위해 별도의 메모리 공간을 할당받아서 사용하는 메모리 공간
- 쿼리의 실행이 완료되면 즉시 시스템으로 반납된다.
- 정렬해야 할 레코드의 건수가 소트 버퍼로 할당된 공간보다 크다면 정렬해야 할 레코드를 여러 조각으로 나눠서 처리하는데</br> 이 과정에서 임시 저장을 위해 디스크를 사용한다.
- 기본 sort buffer size 262144, 262KB.</br>
  책에서 테스트 시 256KB-8MB 사이가 최적의 성능을 보였고, 문서에서는 리눅스 환경 에서 256KB-2MB 사이를 권장한다. 설정된 사이즈를 넘길경우 memory 문제가 생길 수 있다.</br>
  (https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_sort_buffer_size)
- 멀티 머지: 메모리의 소트 버퍼에서 정렬 하고, 그 결과를 임시로 디스크에 기록하고 다음 레코드를 가져와 이 작업을 병합, 반복한다.
- 수행된 멀티 머지 횟수는 sort_merge_passes 변수에 누적 집계된다.
- 소트 버퍼는 세션 메모리 영역에 해당하므로 클라이언트가 공유하지 않는다.
- 커넥션이 많고, 정렬 작업이 많을수록 소트 버퍼로 소비되는 메모리 공간이 커진다.


### 2) 정렬 알고리즘


레코드를 정렬할 때 레코드 전체를 소트 버퍼에 담을지 또는 정렬 기준 칼럼만 소트 버퍼에 담을지에 따라
싱글 패스(Single-pass)/투 패스(Two-pass) 2가지 정렬 모드로 나눈다.

- MySQL 서버의 3가지 정렬 방식
  - <sort_key, rowid>: 정렬 키와 레코드의 로우 아이디(Row ID)만 가져와서 정렬하는 방식
  - <sort_key, additional_fields>: 정렬 키와 레코드 전체를 가져와서 정렬하는 방식으로, 레코드의 칼럼들은 고정 사이즈로 메모리 저장
  - <sort_key, packed_additional_fields>: 정렬 키와 레코드 전체를 가져와서 정렬하는 방식으로, 레코드의 칼럼 들은 가변 사이즈로 메모리 저장


### 3) 싱글 패스 Single-pass
  - <sort_key, additional_fields>, <sort_key, packed_additional_fields>
  - 소트 버퍼에 정렬 기준 칼럼을 포함해 SELECT 대상이 되는 칼럼 전부를 담아서 정렬을 수행하는 정렬 방식이다 </br>
    처음 employees 테이블을 읽을 때 정렬에 필요하지 않은 last_name 칼럼까 지 전부 읽어서 소트 버퍼에 담고 정렬을 수행한다.</br>
    정렬이 완료되면 정렬 버퍼의 내용을 그대 로 클라이언트로 넘겨준다.
    투패스 방식보다 더 많은 소트 버퍼 공간이 필요하다.

![9.2.png](hyunhwaoh-images%2F9.2.png)


### 4) 투 패스
  - <sort_key, rowid>
  - 정렬 대상 칼럼과 프라이머리 키 값만 소트 버퍼에 담아서 정렬을 수행하고, 정렬된 순서대로 다시 프라이머리 키로 테이블을 읽어서 SELECT 할 칼럼을 가져오는 방식이다.
  - 처음 `employees` 테이블을 읽을 때는 정렬에 필요한 `first_name` 칼럼과 프라이머리 키인 `emp_no` 만 읽어서 정렬을 수행한다.
  - 레코드 크기가 `max_length_for_sort_data` 설정 값보다 클때, BLOB, TEXT 타입 컬럼을 SELECT 할때에는 투패스 정렬 방식을 사용한다.

![9.3.png](hyunhwaoh-images%2F9.3.png)


### 5) 정렬 처리 방법
- 쿼리에 ORDER BY가 사용되면 3가지 처리 방법 중 하나로 정렬되고 뒤로갈수록 처리 속도가 떨어진다.
  - a. 인덱스를 사용한 정렬
  - b. 조인에서 드라이밍 테이블만 정렬 (Using filesort 표시)
  - c. 조인에서 조인 결과를 임시 테이블로 저장 후 정렬 (Using temporary; Using filesort 표시)
- 먼저 옵티마이저는 정렬 처리를 위해 인덱스를 이용할 수 있을지 검토한다.
- 인덱스를 이용할 수 있다면 별도의 Filesort 과정 없이 인덱스를 순서대로 읽어서 결과를 반환한다.
- 인덱스를 사용할 수 없다면 WHERE 조건에 일치하는 레코드를 검색해 정렬 버퍼에 저장하면서 정렬을 처리(Filesort)한다.

#### a. 인덱스를 사용한 정렬
인덱스를 이용한 정렬을 위해서는 반드시 ORDER BY에 명시된 칼럼이 제일 먼저 읽는 테이블(드라이빙)에 속하고, ORDER BY의 순서대로 생성된 인덱스가 있어야 한다.</br>
WHERE 절에 첫 번째로 읽는 테이블의 칼럼에 대한 조건이 있다면, 그 조건과 ORDER BY는 같은 인덱스를 사용할 수 있어야 한다.</br>
인덱스를 이용해 정렬이 처리되는 경우에는 실제 인덱스의 값이 정렬돼 있기 때문에 인덱스의 순서대로 읽기만 하면 된다.</br>
별도의 정렬을 위한 추가 작업을 수행하지 않는다

![9.4.png](hyunhwaoh-images%2F9.4.png)


#### b. 조인에서 드라이빙 테이블만 정렬
조인이 수행되면 결과 레코드의 건수와 크기도 늘어난다.</br>
차선책으로 조인을 실행하기 전에 첫 번째 테이블의 레코드를 먼저 정렬한 다음 조인을 실행할 수 있다.</br>
이 방법으로 정렬이 처리되려면 조인에서 첫 번째로 읽히는 테이블(드라이빙 테이블)의 칼럼만으로 ORDER BY 절을 작성해야 한다.


```sql
SELECT *
FROM employees e, salaries s 
WHERE s.emp_no=e.emp_no
    AND e.emp_no BETWEEN 100002 AND 100010
ORDER BY e.last_name;
```

WHERE 절이 다음 2가지 조건을 갖추고 있다면 드라이빙 테이블로 선택한다.
- WHERE 절의 검색 조건(“emp_no BETWEEN 100001 AND 100010”)은 employees 테이블의 프라이머리 키를 이용해 검색하면 작업량을 줄일 수 있다.
- 드리븐 테이블(salaries)의 조인 칼럼인 emp_no 칼럼에 인덱스가 있다.

옵티마이저는 드라이빙 테이블만 검색해서 정렬을 수행하고, 그 결과와 salaries 테이블은 조인한 것이다.

![9.5.png](hyunhwaoh-images%2F9.5.png)

i. 인덱스를 이용해 “emp_no BETWEEN 100001 AND 100010” 조건을 만족하는 9건 검색</br>
ii. 검색 결과를 last_name 칼럼으로 정렬을 수행(Filesort)</br>
iii. 정렬된 결과를 순서대로 읽으면서 salaries 테이블과 조인을 수행해 86건의 결과를 가져옴.


#### c. 조인에서 조인 결과를 임시 테이블로 저장 후 정렬
2개 이상의 테이블을 조인해서 그 결과를 정렬해야 한다면 임시 테이블이 필요할 수도 있다.</br>
이 방법은 정렬의 3가지 방법 가운데 정렬해야 할 레코드 건수가 가장 많기 때문에 가장 느린 정렬 방법이다.

```sql
SELECT *
FROM employees e, salaries s 
WHERE s.emp_no=e.emp_no
    AND e.emp_no BETWEEN 100002 AND 100010
ORDER BY s.salary;
```

위 쿼리의 실행 계획을 살펴보면 Extra 칼럼에 `Using temporary; Using filesort` 가 표시된다.
드리븐 테이블 컬럼 salary 로 정렬하므로, 조인 결과를 임시 테이블에 저장하고 그 결과를 다시 정렬처리하게 된다.

![9.6.png](hyunhwaoh-images%2F9.6.png)


#### d. 정렬 처리 성능 비교
LIMIT 은 테이블이나 처리 결과의 일부만 가져오기 때문에 MySQL 서버가 처리해야 할 작업량이 줄어드는 역할을 한다.</br>
그런데 우선 조건을 만족하는 레코드를 모두 가져와 정렬을 수행하거나 그루핑 작업을 실행해야 LIMIT 건수를 제한할 수 있다.

**쿼리가 처리되는 2가지 방식**

1. 스트리밍 방식</br>
   빠른 응답시간을 위해 사용하는 방식이다.</br>
   처리할 데이터의 양과 관계없이 조건에 일치하는 레코드가 검색될때마다 바로 클라이언트에 전송하는 방식이다.</br>
   풀 테이블 스캔의 결과가 아무 버퍼링 처리나 필터링 과정없이 클라이언트로 스트리밍 된다.</br>
   쿼리를 요청하고 곧바로 첫번째 레코드를 전달받는다.


2. 버퍼링 방식</br>
   ORDER BY 나 GROUP BY 처리는 쿼리 결과 스트리밍이 불가능하다.</br>
   레코드 검색 후 정렬 또는 그루핑작업 하는 동안 클라이언트는 대기해야 한다. 이 방식을 버퍼링 방식 이라고 한다.


> MySQL 서버가 스트리밍 방식으로 처리해서 반환해도
> 클라이언트의 JDBC 라이브러리를 사용한다면 서버로부터 받는 레코드를 일단 내부 버퍼에 담아두고 마지막 결과를 받으면 애플리케이션에 반환한다.
> 이는 불필요한 네트워크 요청을 최소화 하여 전체 처리량을 높이기 위해서이다.
> 하지만 대량의 데이터를 가져와야 항떄 전송방식을 스트리밍 방식으로 변경할 수 있다.

정렬 처리 방식 중 인덱스를 사용한 정렬 방식만 스트리밍 처리 방식이고, 나머지는 버퍼링되서 정렬된다.</br>
어떤 테이블이 먼저 드라이빙 되어 조인되는지도 중요하지만 어떤 정렬 방식으러 처리되는지가 큰 성능 차이가 나므로,</br>
최소 드라이빙 테이블 정렬로 구성하는 것이 좋은 튜닝 방법이다.


> 인덱스를 사용하지 못하는 쿼리는 LIMIT로 조회하더라도 성능이 크게 좋아지지 않는다.


## 4. GROUP BY 처리

GROUP BY 또한 ORDER BY와 같이 쿼리가 스트리밍된 처리를 할 수 없다.</br>

HAVING 절은 GROUP BY 결과에 대해 필터링 역할을 수행한다.</br>

인덱스를 차례대로 읽는 인덱스 스캔 방법과 인덱스를 건너뛰면서 읽는 루스 인덱스 스캔이라는 방법으로 나뉜다.</br>

인덱스를 사용하지 못하는 쿼리에서 임시 테이블을 사용한다.</br>

### 1) 인덱스 스캔을 이용하는 GROUP BY (타이트 인덱스 스캔)
- 조인의 드라이빙 테이블에 속한 칼럼만 이용해 그루핑할 때 GROUP BY 칼럼으로 이미 인덱스가 있다면,
그 인덱스를 차례대로 읽으면서 그루핑 작업을 수행하고 그 결과로 조인을 처리한다.

- 쿼리 실행 계획 Extra 칼럼에 코멘트가 표시되지 않는다.

### 2) 루스 인덱스 스캔을 이용하는 GROUP BY
- 그룹 함수 Aggregation function 등의 그룹값을 처리해야 해서 임시 테이블이 필요할 때도 있다.

- 루스 인덱스 스캔은 인덱스의 레코드를 건너뛰면서 필요한 부분만 읽어서 가져온다.

- 쿼리 실행 계획 Extra 칼럼에 `Using index for group-by` 코멘트 표시.

```sql
EXPLAIN 
    SELECT emp_no 
    FROM salaries 
    WHERE from_date='1958-03-01' 
    GROUP BY emp_no;
```

- salaries 테이블의 인덱스는 (emp_no, from_date)로 생성돼 있다. 
- 위의 쿼리 문장에서 WHERE 조건은 인덱스 레인지 스캔 접근 방식으로 이용할 수 없는 쿼리지만, 실행 계획은 인덱스 레인지 스캔을 이용한다.


### 3) 임시 테이블을 사용하는 GROUP BY

## 5. DISTINCT 처리

### 1) SELECT DISTINCT ...

### 2) 집합 함수와 함께 사용된 DISTINCT


## 6. 내부 임시 테이블 사용

### 1) 메모리 임시 테이블과 디스크 임시 테이블

### 2) 임시 테이블이 필요한 쿼리

### 3) 임시 테이블이 디스크에 생성되는 경우

### 4) 임시 테이블 관련 상태 변수

